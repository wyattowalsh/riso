# FastAPI Patterns & Best Practices

**Context**: Advanced patterns for extending FastAPI applications generated by the Riso template.

## Table of Contents

- [Configuration Patterns](#configuration-patterns)
- [Authentication & Authorization](#authentication--authorization)
- [Database Integration](#database-integration)
- [Background Tasks](#background-tasks)
- [WebSockets](#websockets)
- [Caching](#caching)
- [Rate Limiting](#rate-limiting)
- [Documentation Patterns](#documentation-patterns)
- [Testing Patterns](#testing-patterns)
- [Deployment Patterns](#deployment-patterns)

## Configuration Patterns

### Environment-Specific Configuration

```python
# config.py
from pydantic import Field, field_validator
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    # Environment-specific database URLs
    database_url: str = Field(
        default="sqlite:///./dev.db",
        description="Database connection URL"
    )
    
    @field_validator("database_url")
    @classmethod
    def validate_db_url(cls, v: str, info) -> str:
        """Ensure production uses PostgreSQL."""
        environment = info.data.get("environment", "development")
        if environment == "production" and v.startswith("sqlite"):
            raise ValueError("Production must use PostgreSQL, not SQLite")
        return v
```

### Secrets Management

```python
# config.py
import os
from pydantic import Field, SecretStr

class Settings(BaseSettings):
    # Secrets
    jwt_secret: SecretStr = Field(..., description="JWT signing key")
    api_key: SecretStr = Field(..., description="External API key")
    
    # Load from environment or secrets manager
    @classmethod
    def from_secrets_manager(cls):
        """Load secrets from AWS Secrets Manager, Azure Key Vault, etc."""
        # Example with AWS Secrets Manager
        import boto3
        client = boto3.client('secretsmanager')
        secret = client.get_secret_value(SecretId='prod/api/secrets')
        return cls.model_validate_json(secret['SecretString'])
```

### Feature Flags

```python
# config.py
class Settings(BaseSettings):
    # Feature flags
    enable_new_feature: bool = Field(default=False)
    enable_beta_api: bool = Field(default=False)
    
    # Rate limiting
    rate_limit_enabled: bool = Field(default=True)
    rate_limit_per_minute: int = Field(default=60)

# main.py
settings = get_settings()

if settings.enable_beta_api:
    from api.routes import beta
    app.include_router(beta.router)
```

### Deployment Configuration

```python
# config.py
class Settings(BaseSettings):
    # Worker configuration
    workers: int = Field(default=4, description="Number of worker processes")
    max_requests: int = Field(default=1000, description="Max requests before restart")
    max_requests_jitter: int = Field(default=100)
    
    # Connection pools
    db_pool_size: int = Field(default=20)
    db_max_overflow: int = Field(default=10)
    db_pool_timeout: int = Field(default=30)
    
    # Timeouts
    request_timeout: int = Field(default=30, description="Request timeout in seconds")
    keepalive_timeout: int = Field(default=5)
```

## Authentication & Authorization

### JWT Authentication

```python
# middleware/auth.py
from datetime import datetime, timedelta
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

def create_access_token(data: dict, expires_delta: timedelta = None):
    """Create JWT access token."""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=15))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, settings.jwt_secret.get_secret_value(), algorithm="HS256")

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify JWT and return current user."""
    try:
        payload = jwt.decode(
            credentials.credentials,
            settings.jwt_secret.get_secret_value(),
            algorithms=["HS256"]
        )
        user_id: str = payload.get("sub")
        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

# routes/protected.py
@router.get("/protected")
async def protected_route(user_id: str = Depends(get_current_user)):
    return {"user_id": user_id, "message": "Access granted"}
```

### OAuth2 with Password Flow

```python
# routes/auth.py
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@router.post("/token")
async def login(form_data: OAuth2PasswordRequestForm = Depends()):
    """Login endpoint returning JWT token."""
    user = authenticate_user(form_data.username, form_data.password)
    if not user:
        raise HTTPException(status_code=401, detail="Incorrect credentials")
    
    access_token = create_access_token(data={"sub": user.id})
    return {"access_token": access_token, "token_type": "bearer"}
```

### Role-Based Access Control

```python
# middleware/auth.py
from enum import Enum
from functools import wraps

class Role(str, Enum):
    ADMIN = "admin"
    USER = "user"
    GUEST = "guest"

def require_role(*allowed_roles: Role):
    """Decorator to require specific roles."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, current_user=Depends(get_current_user), **kwargs):
            if current_user.role not in allowed_roles:
                raise HTTPException(status_code=403, detail="Insufficient permissions")
            return await func(*args, current_user=current_user, **kwargs)
        return wrapper
    return decorator

# Usage
@router.delete("/users/{user_id}")
@require_role(Role.ADMIN)
async def delete_user(user_id: str, current_user: User = Depends(get_current_user)):
    """Only admins can delete users."""
    pass
```

## Database Integration

### SQLAlchemy (Async)

```python
# database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import declarative_base

engine = create_async_engine(settings.database_url, echo=settings.is_development())
async_session = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
Base = declarative_base()

async def get_db():
    """Database session dependency."""
    async with async_session() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
        finally:
            await session.close()

# models/db/user.py
from sqlalchemy import Column, String, Integer
from database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(50), unique=True, nullable=False)
    email = Column(String(255), unique=True, nullable=False)

# routes/users.py
from sqlalchemy import select

@router.get("/users/")
async def list_users(db: AsyncSession = Depends(get_db)):
    result = await db.execute(select(User))
    users = result.scalars().all()
    return [UserResponse.model_validate(user) for user in users]
```

### Alembic Migrations

```bash
# Initialize Alembic
uv run alembic init migrations

# Create migration
uv run alembic revision --autogenerate -m "create users table"

# Apply migrations
uv run alembic upgrade head
```

## Background Tasks

### FastAPI Background Tasks

```python
from fastapi import BackgroundTasks

def send_email(email: str, message: str):
    """Send email in background."""
    # Email sending logic
    pass

@router.post("/users/")
async def create_user(
    request: UserCreateRequest,
    background_tasks: BackgroundTasks
):
    """Create user and send welcome email."""
    user = create_user_in_db(request)
    background_tasks.add_task(send_email, user.email, "Welcome!")
    return user
```

### Celery Integration

```python
# celery_app.py
from celery import Celery

celery_app = Celery(
    "tasks",
    broker=settings.celery_broker_url,
    backend=settings.celery_result_backend
)

@celery_app.task
def process_large_file(file_id: str):
    """Process file asynchronously."""
    # Heavy processing logic
    pass

# routes/files.py
@router.post("/files/")
async def upload_file(file: UploadFile):
    """Upload file and process async."""
    file_id = save_file(file)
    process_large_file.delay(file_id)  # Celery task
    return {"file_id": file_id, "status": "processing"}
```

## WebSockets

```python
# routes/ws.py
from fastapi import WebSocket, WebSocketDisconnect

class ConnectionManager:
    def __init__(self):
        self.active_connections: list[WebSocket] = []
    
    async def connect(self, websocket: WebSocket):
        await websocket.accept()
        self.active_connections.append(websocket)
    
    def disconnect(self, websocket: WebSocket):
        self.active_connections.remove(websocket)
    
    async def broadcast(self, message: str):
        for connection in self.active_connections:
            await connection.send_text(message)

manager = ConnectionManager()

@router.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: str):
    await manager.connect(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            await manager.broadcast(f"Client {client_id}: {data}")
    except WebSocketDisconnect:
        manager.disconnect(websocket)
        await manager.broadcast(f"Client {client_id} disconnected")
```

## Caching

### Redis Caching

```python
# cache.py
import redis.asyncio as redis
from functools import wraps
import json

redis_client = redis.from_url(settings.redis_url)

def cache(expire: int = 300):
    """Cache decorator with Redis."""
    def decorator(func):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            # Generate cache key
            key = f"{func.__name__}:{str(args)}:{str(kwargs)}"
            
            # Check cache
            cached = await redis_client.get(key)
            if cached:
                return json.loads(cached)
            
            # Call function
            result = await func(*args, **kwargs)
            
            # Store in cache
            await redis_client.setex(key, expire, json.dumps(result))
            return result
        return wrapper
    return decorator

# Usage
@router.get("/expensive-data")
@cache(expire=3600)  # Cache for 1 hour
async def get_expensive_data():
    # Expensive computation
    return compute_data()
```

## Rate Limiting

### slowapi Integration

```python
# middleware/rate_limit.py
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)

# main.py
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# routes/api.py
@router.get("/limited")
@limiter.limit("5/minute")
async def rate_limited_route(request: Request):
    return {"message": "This route is rate limited"}
```

### Custom Rate Limiting

```python
# middleware/custom_rate_limit.py
from datetime import datetime, timedelta
from collections import defaultdict
from fastapi import HTTPException

class RateLimiter:
    def __init__(self, max_requests: int, window: timedelta):
        self.max_requests = max_requests
        self.window = window
        self.requests = defaultdict(list)
    
    def is_allowed(self, key: str) -> bool:
        now = datetime.now()
        cutoff = now - self.window
        
        # Clean old requests
        self.requests[key] = [
            req_time for req_time in self.requests[key]
            if req_time > cutoff
        ]
        
        # Check limit
        if len(self.requests[key]) >= self.max_requests:
            return False
        
        self.requests[key].append(now)
        return True

limiter = RateLimiter(max_requests=100, window=timedelta(minutes=1))

@router.get("/api/data")
async def get_data(request: Request):
    if not limiter.is_allowed(request.client.host):
        raise HTTPException(status_code=429, detail="Rate limit exceeded")
    return {"data": "..."}
```

## Documentation Patterns

### Adding Custom Examples

```python
from pydantic import Field

class UserCreateRequest(BaseModel):
    username: str = Field(
        ...,
        min_length=3,
        examples=["john_doe", "alice123"]
    )
    email: str = Field(
        ...,
        examples=["user@example.com"]
    )

@router.post(
    "/users/",
    response_model=UserResponse,
    responses={
        201: {
            "description": "User created successfully",
            "content": {
                "application/json": {
                    "example": {
                        "id": "123",
                        "username": "john_doe",
                        "email": "john@example.com"
                    }
                }
            }
        },
        400: {"description": "Invalid input"}
    }
)
async def create_user(request: UserCreateRequest):
    """Create a new user with validation."""
    pass
```

### API Versioning

```python
# routes/v1/users.py
router_v1 = APIRouter(prefix="/v1/users", tags=["Users V1"])

@router_v1.get("/")
async def list_users_v1():
    """V1 API - Returns basic user info."""
    pass

# routes/v2/users.py
router_v2 = APIRouter(prefix="/v2/users", tags=["Users V2"])

@router_v2.get("/")
async def list_users_v2():
    """V2 API - Returns extended user info."""
    pass

# main.py
app.include_router(router_v1)
app.include_router(router_v2)
```

### Organizing Tags

```python
# main.py
app = FastAPI(
    title="My API",
    openapi_tags=[
        {
            "name": "users",
            "description": "User management operations"
        },
        {
            "name": "admin",
            "description": "Administrative operations",
            "externalDocs": {
                "description": "Admin guide",
                "url": "https://docs.example.com/admin"
            }
        }
    ]
)
```

## Testing Patterns

### Mocking Dependencies

```python
# tests/test_api.py
from unittest.mock import Mock, AsyncMock

def test_with_mock_db(client):
    """Test with mocked database."""
    mock_db = Mock()
    mock_db.query.return_value.all.return_value = []
    
    app.dependency_overrides[get_db] = lambda: mock_db
    
    response = client.get("/users/")
    assert response.status_code == 200
    
    app.dependency_overrides.clear()
```

### Testing Authentication

```python
@pytest.fixture
def auth_token():
    """Generate test JWT token."""
    return create_access_token({"sub": "test_user"})

def test_protected_route(client, auth_token):
    """Test authenticated endpoint."""
    headers = {"Authorization": f"Bearer {auth_token}"}
    response = client.get("/protected", headers=headers)
    assert response.status_code == 200
```

## Deployment Patterns

### Production Server Configuration

```bash
# Gunicorn with Uvicorn workers
gunicorn api.main:app \
  --workers 4 \
  --worker-class uvicorn.workers.UvicornWorker \
  --bind 0.0.0.0:8000 \
  --access-logfile - \
  --error-logfile - \
  --log-level info
```

### Docker Multi-Stage Build

```dockerfile
# Builder stage
FROM python:3.11-slim as builder
WORKDIR /app
COPY pyproject.toml uv.lock ./
RUN pip install uv && uv sync --no-dev

# Runtime stage
FROM python:3.11-slim
WORKDIR /app
COPY --from=builder /app/.venv /app/.venv
COPY . .
EXPOSE 8000
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:8000/health/live || exit 1
CMD [".venv/bin/uvicorn", "api.main:app", "--host", "0.0.0.0"]
```

### Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: fastapi-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: fastapi
  template:
    metadata:
      labels:
        app: fastapi
    spec:
      containers:
      - name: api
        image: myapp:latest
        ports:
        - containerPort: 8000
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: RELOAD
          value: "false"
        livenessProbe:
          httpGet:
            path: /health/live
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
```

## Additional Resources

- **FastAPI Documentation**: https://fastapi.tiangolo.com
- **Pydantic V2**: https://docs.pydantic.dev/2.0/
- **SQLAlchemy 2.0**: https://docs.sqlalchemy.org/en/20/
- **Alembic**: https://alembic.sqlalchemy.org/
- **Celery**: https://docs.celeryq.dev/
- **Redis**: https://redis.io/docs/

---

**Note**: This guide provides patterns for extending the FastAPI scaffold. All code should be adapted to your specific requirements and thoroughly tested.
