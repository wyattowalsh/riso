"""Reusable logic helpers shared by CLI and API modules."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Iterable, Mapping

ENABLED = {{ "True" if shared_logic | lower == "enabled" else "False" }}


@dataclass(slots=True)
class HealthCheckResult:
    """Represents the outcome of a service health check."""

    name: str
    status: str = "ok"
    details: Mapping[str, object] | None = None

    def as_dict(self) -> dict[str, object]:
        payload: dict[str, object] = {"name": self.name, "status": self.status}
        if self.details:
            payload["details"] = dict(self.details)
        return payload


def build_health_payload(
    service: str,
    *,
    checks: Iterable[HealthCheckResult] | None = None,
    dry_run: bool = False,
) -> dict[str, object]:
    """Compose a standard health payload for services and CLIs."""

    payload: dict[str, object] = {
        "service": service,
        "status": "ok",
        "timestamp": datetime.now(tz=timezone.utc).isoformat(),
        "dry_run": dry_run,
    }
    if checks:
        payload["checks"] = [item.as_dict() for item in checks]
        if any(item.status != "ok" for item in checks):
            payload["status"] = "degraded"

    if not ENABLED:
        payload.setdefault("notes", []).append(
            "Shared logic module disabled during render; using fallback payload."
        )

    return payload


def summarize_payload(payload: Mapping[str, object]) -> str:
    """Generate a concise human-readable summary for console output."""

    status = payload.get("status", "unknown")
    service = payload.get("service", "service")
    dry_run = payload.get("dry_run", False)
    suffix = " (dry run)" if dry_run else ""
    return f"{service} status: {status}{suffix}"

@dataclass(slots=True)
class ToolchainProvisioningAttempt:
    """Represents a single toolchain provisioning attempt captured during render."""

    tool_name: str
    version_requested: str
    status: str
    timestamp: str
    stderr: str | None = None
    next_steps: str | None = None
    retry_command: str | None = None

    def to_dict(self) -> dict[str, object]:
        payload: dict[str, object] = {
            "tool_name": self.tool_name,
            "version_requested": self.version_requested,
            "status": self.status,
            "timestamp": self.timestamp,
        }
        if self.stderr:
            payload["stderr"] = self.stderr
        if self.next_steps:
            payload["next_steps"] = self.next_steps
        if self.retry_command:
            payload["retry_command"] = self.retry_command
        return payload


@dataclass(slots=True)
class SupportTicketMetric:
    """Snapshot of documentation-related support tickets for governance checks."""

    observed_at: str
    ticket_count: int
    variance_percent: float
    threshold_exceeded: bool

    def to_dict(self) -> dict[str, object]:
        return {
            "observed_at": self.observed_at,
            "ticket_count": self.ticket_count,
            "variance_percent": self.variance_percent,
            "threshold_exceeded": self.threshold_exceeded,
        }


@dataclass(slots=True)
class ArtifactExpiryAlert:
    """Represents an impending documentation artifact expiry event."""

    variant_name: str
    expires_at: str
    days_remaining: int
    warning_emitted: bool

    def to_dict(self) -> dict[str, object]:
        return {
            "variant_name": self.variant_name,
            "expires_at": self.expires_at,
            "days_remaining": self.days_remaining,
            "warning_emitted": self.warning_emitted,
        }


__all__ = [
    "HealthCheckResult",
    "ToolchainProvisioningAttempt",
    "SupportTicketMetric",
    "ArtifactExpiryAlert",
    "build_health_payload",
    "summarize_payload",
    "ENABLED",
]
