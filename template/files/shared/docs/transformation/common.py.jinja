"""
Content transformation utilities for documentation.
Feature: 018-docs-sites-overhaul
Generated by Riso template for {{ project_name }}
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import Callable, List, Optional


class ContentFormat(Enum):
    """Supported documentation content formats."""
    MARKDOWN = "markdown"
    MDX = "mdx"
    RST = "rst"


class TransformationFailureMode(Enum):
    """How to handle transformation failures."""
    ERROR = "error"  # Halt build immediately (per spec clarification Q1)
    WARN = "warn"    # Log warning and continue
    SKIP = "skip"    # Skip transformation, preserve original


@dataclass
class TransformationError:
    """Error encountered during content transformation."""
    file_path: str
    line_number: int
    error_type: str  # UNSUPPORTED_SYNTAX, MALFORMED_INPUT, ENCODING_ERROR, INVALID_REFERENCE
    description: str
    suggestion: str  # Manual override instructions


@dataclass
class TransformationResult:
    """Result of content transformation."""
    success: bool
    content: Optional[str]
    errors: List[TransformationError]
    warnings: List[str]

    def log_errors(self) -> None:
        """Log all errors with actionable details."""
        for error in self.errors:
            print(f"[ERROR] {error.file_path}:{error.line_number}: {error.error_type} - {error.description}")
            print(f"Suggestion: {error.suggestion}")

    def log_warnings(self) -> None:
        """Log all warnings."""
        for warning in self.warnings:
            print(f"[WARNING]: {warning}")

    def raise_if_failed(self) -> None:
        """Raise exception if transformation failed (for build halting)."""
        if not self.success:
            self.log_errors()
            raise RuntimeError(f"Content transformation failed with {len(self.errors)} error(s)")


@dataclass
class ContentTransformationRule:
    """Rule for transforming content between documentation formats."""
    source_format: ContentFormat
    target_format: ContentFormat
    transformation_fn: Callable[[str], str]
    supported_extensions: List[str]  # e.g., ["mermaid", "code-tabs", "admonitions"]
    failure_mode: TransformationFailureMode

    def apply(self, content: str, file_path: str) -> TransformationResult:
        """
        Apply transformation rule to content.
        
        Args:
            content: Source content to transform
            file_path: Path to source file (for error reporting)
            
        Returns:
            TransformationResult with success status and transformed content or errors
        """
        try:
            transformed_content = self.transformation_fn(content)
            return TransformationResult(
                success=True,
                content=transformed_content,
                errors=[],
                warnings=[]
            )
        except Exception as e:
            if self.failure_mode == TransformationFailureMode.ERROR:
                return TransformationResult(
                    success=False,
                    content=None,
                    errors=[TransformationError(
                        file_path=file_path,
                        line_number=self._extract_line_number(e),
                        error_type="TRANSFORMATION_ERROR",
                        description=str(e),
                        suggestion=self._get_manual_override_suggestion(e)
                    )],
                    warnings=[]
                )
            elif self.failure_mode == TransformationFailureMode.WARN:
                return TransformationResult(
                    success=True,
                    content=content,  # Return original
                    errors=[],
                    warnings=[f"Transformation warning in {file_path}: {e}"]
                )
            else:  # SKIP
                return TransformationResult(
                    success=True,
                    content=content,  # Return original
                    errors=[],
                    warnings=[]
                )

    def _extract_line_number(self, exception: Exception) -> int:
        """Extract line number from exception if available."""
        # Basic implementation - can be enhanced with more sophisticated parsing
        import traceback
        tb = traceback.extract_tb(exception.__traceback__)
        if tb:
            return tb[-1].lineno
        return 0

    def _get_manual_override_suggestion(self, exception: Exception) -> str:
        """Provide manual override instructions for common failures."""
        error_str = str(exception).lower()
        if "syntax" in error_str or "parse" in error_str:
            return "Please manually convert this syntax for the target framework. See docs for framework-specific directives."
        elif "encoding" in error_str:
            return "Check file encoding. Ensure UTF-8 encoding for all documentation files."
        elif "reference" in error_str or "link" in error_str:
            return "Update cross-references to match target framework format (e.g., :doc: for Sphinx, relative paths for MDX)."
        return "Please review the content and manually adjust for the target framework."


class ContentTransformer:
    """
    Main content transformation engine.
    Transforms documentation content between formats while preserving semantic structure.
    """

    def __init__(self):
        self.rules: List[ContentTransformationRule] = []

    def register_rule(self, rule: ContentTransformationRule) -> None:
        """Register a transformation rule."""
        self.rules.append(rule)

    def transform(
        self,
        content: str,
        source_format: ContentFormat,
        target_format: ContentFormat,
        file_path: str = "<unknown>"
    ) -> TransformationResult:
        """
        Transform content from source format to target format.
        
        Args:
            content: Source content
            source_format: Source format
            target_format: Target format
            file_path: Source file path for error reporting
            
        Returns:
            TransformationResult with success status and transformed content or errors
        """
        # Find matching rule
        for rule in self.rules:
            if rule.source_format == source_format and rule.target_format == target_format:
                return rule.apply(content, file_path)

        # No rule found - return unchanged with warning
        return TransformationResult(
            success=True,
            content=content,
            errors=[],
            warnings=[f"No transformation rule found for {source_format.value} â†’ {target_format.value}"]
        )
