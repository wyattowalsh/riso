"""
Accessibility validator using WCAG 2.1 Level AA.
Feature: 018-docs-sites-overhaul
Generated by Riso template for {{ project_name }}
"""

from pathlib import Path
from typing import List
from .common import (
    A11yWarning,
    A11yError,
    ValidationResults,
)


class AccessibilityValidator:
    """
    Accessibility validator using WCAG 2.1 Level AA (FR-013, T075).
    Warnings are non-blocking per spec clarification Q3.
    """

    def __init__(self):
        self.wcag_level = "AA"
        self.standard = "WCAG 2.1"

    def validate(self, build_dir: Path) -> ValidationResults:
        """
        Validate documentation accessibility.
        
        Args:
            build_dir: Path to built documentation
            
        Returns:
            ValidationResults with accessibility findings
        """
        warnings: List[A11yWarning] = []
        errors: List[A11yError] = []

        # Find all HTML files
        html_files = list(build_dir.rglob("*.html"))
        
        for html_file in html_files:
            file_warnings, file_errors = self._check_file(html_file)
            warnings.extend(file_warnings)
            errors.extend(file_errors)

        return ValidationResults(
            link_check_passed=True,
            broken_internal_links=[],
            broken_external_links=[],
            accessibility_warnings=warnings,
            accessibility_errors=errors,
            missing_images=[],
            invalid_cross_refs=[]
        )

    def _check_file(self, html_file: Path) -> tuple:
        """Check single HTML file for accessibility issues."""
        warnings = []
        errors = []
        
        content = html_file.read_text(errors='ignore')
        page_url = str(html_file)

        # Basic accessibility checks
        # In production, this would use axe-core or pa11y
        
        # Check for images without alt text
        import re
        img_pattern = r'<img(?![^>]*alt=)[^>]*>'
        imgs_without_alt = re.findall(img_pattern, content)
        
        for img in imgs_without_alt:
            warnings.append(A11yWarning(
                rule_id="image-alt",
                impact="serious",
                page_url=page_url,
                element_selector="img",
                help_text="Images must have alternate text (alt attribute)",
                wcag_criteria=["1.1.1"]
            ))

        # Check for proper heading hierarchy
        h1_count = len(re.findall(r'<h1[^>]*>', content))
        if h1_count == 0:
            warnings.append(A11yWarning(
                rule_id="page-has-heading-one",
                impact="moderate",
                page_url=page_url,
                element_selector="body",
                help_text="Page should have exactly one h1 heading",
                wcag_criteria=["2.4.1", "2.4.6"]
            ))
        elif h1_count > 1:
            warnings.append(A11yWarning(
                rule_id="page-has-heading-one",
                impact="moderate",
                page_url=page_url,
                element_selector="h1",
                help_text=f"Page has {h1_count} h1 headings, should have exactly one",
                wcag_criteria=["2.4.1", "2.4.6"]
            ))

        # Check for form labels
        inputs_without_labels = re.findall(
            r'<input(?![^>]*aria-label)(?![^>]*id="[^"]*")(?![^>]*type="hidden")[^>]*>',
            content
        )
        
        for input_elem in inputs_without_labels:
            warnings.append(A11yWarning(
                rule_id="label",
                impact="serious",
                page_url=page_url,
                element_selector="input",
                help_text="Form elements must have labels",
                wcag_criteria=["1.3.1", "3.3.2", "4.1.2"]
            ))

        return warnings, errors

    def generate_report(self, results: ValidationResults) -> str:
        """Generate human-readable accessibility report."""
        lines = ["# Accessibility Validation Report\n"]
        lines.append(f"**Standard**: {self.standard} Level {self.wcag_level}\n")
        
        if results.accessibility_warnings:
            lines.append(f"\n## Warnings ({len(results.accessibility_warnings)})\n")
            lines.append("*Non-blocking per spec clarification Q3*\n")
            
            for warning in results.accessibility_warnings[:20]:  # Limit output
                lines.append(f"\n### [{warning.rule_id}] - {warning.impact.upper()}")
                lines.append(f"**Page**: {warning.page_url}")
                lines.append(f"**Help**: {warning.help_text}")
                lines.append(f"**WCAG**: {', '.join(warning.wcag_criteria)}")
        
        if results.accessibility_errors:
            lines.append(f"\n## Critical Errors ({len(results.accessibility_errors)})\n")
            for error in results.accessibility_errors:
                lines.append(f"\n### [{error.rule_id}] - CRITICAL")
                lines.append(f"**Page**: {error.page_url}")
                lines.append(f"**Help**: {error.help_text}")
        
        if not results.accessibility_warnings and not results.accessibility_errors:
            lines.append("\nâœ… No accessibility issues found!")
        
        return '\n'.join(lines)
