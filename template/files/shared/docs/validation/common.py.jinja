"""
Documentation validation utilities.
Feature: 018-docs-sites-overhaul
Generated by Riso template for {{ project_name }}
"""

from dataclasses import dataclass
from enum import Enum
from pathlib import Path
from typing import List, Literal, Optional
import time


class RetryConfig:
    """Configuration for link checking retry logic with exponential backoff."""

    def __init__(
        self,
        max_attempts: int = 3,  # Per spec clarification Q2
        initial_delay: float = 1.0,  # seconds
        backoff_factor: float = 2.0,  # Exponential backoff
        timeout: float = 10.0  # seconds per request
    ):
        self.max_attempts = max_attempts
        self.initial_delay = initial_delay
        self.backoff_factor = backoff_factor
        self.timeout = timeout

    def get_delay(self, attempt: int) -> float:
        """Calculate delay for given attempt number (0-indexed)."""
        return self.initial_delay * (self.backoff_factor ** attempt)

    def should_retry(self, attempt: int) -> bool:
        """True if should retry after given attempt."""
        return attempt < self.max_attempts


@dataclass
class BrokenLink:
    """Details of a broken link."""
    url: str
    source_file: Path
    source_line: int
    status_code: Optional[int]
    error_message: str
    retry_attempts: int  # After 3 retries per spec clarification Q2


@dataclass
class A11yWarning:
    """WCAG 2.1 Level AA accessibility warning (non-blocking per spec clarification Q3)."""
    rule_id: str
    impact: Literal["minor", "moderate", "serious", "critical"]
    page_url: str
    element_selector: str
    help_text: str
    wcag_criteria: List[str]  # e.g., ["1.4.3", "1.4.6"]


@dataclass
class A11yError:
    """Critical accessibility error (blocking)."""
    rule_id: str
    impact: Literal["critical"]
    page_url: str
    element_selector: str
    help_text: str


@dataclass
class ValidationResults:
    """Comprehensive validation results for documentation build."""

    link_check_passed: bool
    broken_internal_links: List[BrokenLink]
    broken_external_links: List[BrokenLink]  # After retries
    accessibility_warnings: List[A11yWarning]  # WCAG 2.1 AA (non-blocking per Q3)
    accessibility_errors: List[A11yError]  # Critical issues only
    missing_images: List[str]
    invalid_cross_refs: List[str]

    @property
    def has_no_critical_errors(self) -> bool:
        """True if no critical errors (broken internal links, accessibility errors)."""
        return (
            len(self.broken_internal_links) == 0 and
            len(self.accessibility_errors) == 0
        )

    @property
    def total_issues(self) -> int:
        """Total count of all issues (warnings + errors)."""
        return (
            len(self.broken_internal_links) +
            len(self.broken_external_links) +
            len(self.accessibility_warnings) +
            len(self.accessibility_errors) +
            len(self.missing_images) +
            len(self.invalid_cross_refs)
        )

    def generate_report(self) -> str:
        """Generate human-readable validation report."""
        lines = ["# Documentation Validation Report\n"]

        lines.append(f"**Link Check**: {'✅ PASSED' if self.link_check_passed else '❌ FAILED'}")
        
        if self.broken_internal_links:
            lines.append(f"\n## Broken Internal Links ({len(self.broken_internal_links)})\n")
            for link in self.broken_internal_links:
                lines.append(f"- `{link.url}` in {link.source_file}:{link.source_line}")

        if self.broken_external_links:
            lines.append(f"\n## Broken External Links ({len(self.broken_external_links)})\n")
            lines.append("*After 3 retry attempts with exponential backoff*\n")
            for link in self.broken_external_links:
                lines.append(f"- `{link.url}` (HTTP {link.status_code or 'N/A'})")

        if self.accessibility_warnings:
            lines.append(f"\n## Accessibility Warnings ({len(self.accessibility_warnings)})\n")
            lines.append("*WCAG 2.1 Level AA - Non-blocking*\n")
            for warning in self.accessibility_warnings[:10]:  # Limit to 10
                lines.append(f"- [{warning.rule_id}] {warning.help_text} (Impact: {warning.impact})")
            if len(self.accessibility_warnings) > 10:
                lines.append(f"  *(and {len(self.accessibility_warnings) - 10} more...)*")

        if self.accessibility_errors:
            lines.append(f"\n## Critical Accessibility Errors ({len(self.accessibility_errors)})\n")
            for error in self.accessibility_errors:
                lines.append(f"- [{error.rule_id}] {error.help_text}")

        return "\n".join(lines)


class DocumentationValidator:
    """
    Main documentation validation engine.
    Validates links, accessibility, images, and cross-references.
    """

    def __init__(self, retry_config: Optional[RetryConfig] = None):
        self.retry_config = retry_config or RetryConfig()

    def validate_link(self, url: str, source_file: Path, source_line: int) -> Optional[BrokenLink]:
        """
        Validate a single link with retry logic.
        
        Args:
            url: URL to validate
            source_file: Source file containing the link
            source_line: Line number in source file
            
        Returns:
            BrokenLink if link is broken after retries, None if valid
        """
        try:
            import requests
        except ImportError:
            return None  # Skip validation if requests not available

        attempt = 0
        last_error = None

        while attempt < self.retry_config.max_attempts:
            try:
                response = requests.head(
                    url,
                    timeout=self.retry_config.timeout,
                    allow_redirects=True
                )
                if response.status_code < 400:
                    return None  # Link is valid
                last_error = f"HTTP {response.status_code}"
            except Exception as e:
                last_error = str(e)

            attempt += 1
            if attempt < self.retry_config.max_attempts:
                delay = self.retry_config.get_delay(attempt)
                time.sleep(delay)

        # All retries exhausted
        return BrokenLink(
            url=url,
            source_file=source_file,
            source_line=source_line,
            status_code=None,
            error_message=last_error or "Unknown error",
            retry_attempts=attempt
        )

    def validate_documentation(
        self,
        build_dir: Path,
        check_external_links: bool = True
    ) -> ValidationResults:
        """
        Validate built documentation.
        
        Args:
            build_dir: Path to built documentation directory
            check_external_links: Whether to check external links (slower)
            
        Returns:
            ValidationResults with all validation findings
        """
        # Placeholder implementation - actual validation would:
        # 1. Parse HTML/MD files for links
        # 2. Check internal links exist
        # 3. Check external links with retry logic
        # 4. Run axe-core for accessibility
        # 5. Verify image references
        
        return ValidationResults(
            link_check_passed=True,
            broken_internal_links=[],
            broken_external_links=[],
            accessibility_warnings=[],
            accessibility_errors=[],
            missing_images=[],
            invalid_cross_refs=[]
        )
