"""
Link checker with exponential backoff retry logic.
Feature: 018-docs-sites-overhaul
Generated by Riso template for {{ project_name }}
"""

import time
from pathlib import Path
from typing import List, Optional
from .common import (
    BrokenLink,
    RetryConfig,
    ValidationResults,
    DocumentationValidator,
)


class LinkChecker:
    """
    Link checker with exponential backoff retry logic (FR-012, T074).
    Implements 3 retry attempts with 1s→2s→4s delays as specified in spec.
    """

    def __init__(self, retry_config: Optional[RetryConfig] = None):
        self.retry_config = retry_config or RetryConfig(
            max_attempts=3,
            initial_delay=1.0,
            backoff_factor=2.0,
            timeout=10.0
        )
        self.validator = DocumentationValidator(self.retry_config)

    def check_links(
        self,
        build_dir: Path,
        check_external: bool = True
    ) -> ValidationResults:
        """
        Check all links in documentation build.
        
        Args:
            build_dir: Path to built documentation
            check_external: Whether to check external links (slower)
            
        Returns:
            ValidationResults with link check findings
        """
        broken_internal: List[BrokenLink] = []
        broken_external: List[BrokenLink] = []

        # Find all HTML files
        html_files = list(build_dir.rglob("*.html"))
        
        for html_file in html_files:
            internal, external = self._extract_links(html_file)
            
            # Check internal links
            for link, line_num in internal:
                if not self._check_internal_link(build_dir, html_file, link):
                    broken_internal.append(BrokenLink(
                        url=link,
                        source_file=html_file,
                        source_line=line_num,
                        status_code=404,
                        error_message="Internal link not found",
                        retry_attempts=0
                    ))
            
            # Check external links with retry
            if check_external:
                for link, line_num in external:
                    broken = self.validator.validate_link(link, html_file, line_num)
                    if broken:
                        broken_external.append(broken)

        return ValidationResults(
            link_check_passed=len(broken_internal) == 0,
            broken_internal_links=broken_internal,
            broken_external_links=broken_external,
            accessibility_warnings=[],
            accessibility_errors=[],
            missing_images=[],
            invalid_cross_refs=[]
        )

    def _extract_links(self, html_file: Path) -> tuple:
        """Extract internal and external links from HTML file."""
        import re
        
        content = html_file.read_text(errors='ignore')
        
        # Find all href attributes
        href_pattern = r'href=["\']([^"\']+)["\']'
        links = re.findall(href_pattern, content)
        
        internal = []
        external = []
        
        for i, link in enumerate(links, 1):
            if link.startswith('http://') or link.startswith('https://'):
                external.append((link, i))
            elif link.startswith('#') or link.startswith('mailto:'):
                # Skip anchors and mailto
                continue
            else:
                internal.append((link, i))
        
        return internal, external

    def _check_internal_link(
        self,
        build_dir: Path,
        source_file: Path,
        link: str
    ) -> bool:
        """Check if internal link target exists."""
        # Resolve relative link
        if link.startswith('/'):
            target = build_dir / link.lstrip('/')
        else:
            target = (source_file.parent / link).resolve()
        
        # Check if target exists
        if target.exists():
            return True
        
        # Try with .html extension
        if not link.endswith('.html') and (target.parent / f"{target.name}.html").exists():
            return True
        
        return False
