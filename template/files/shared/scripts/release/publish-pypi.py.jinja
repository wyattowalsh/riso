{% if changelog_module == "enabled" and api_tracks in ['python', 'python+node'] -%}
#!/usr/bin/env python3
"""Publish Python packages to PyPI.

This script builds and publishes Python packages to PyPI using twine.
It supports dry-run mode and retry logic for reliability.

Usage:
    python publish-pypi.py [--dry-run]

Environment Variables:
    PYPI_TOKEN: PyPI API token for authentication
    DRY_RUN: Set to 'true' to skip actual publishing

Generated by Riso template - Feature 014: Changelog & Release Management
"""

import os
import subprocess
import sys
import time
from pathlib import Path
from typing import Optional


def run_command(cmd: list[str], check: bool = True) -> subprocess.CompletedProcess:
    """Run a shell command and capture output.
    
    Args:
        cmd: Command and arguments
        check: Whether to raise exception on non-zero exit
        
    Returns:
        CompletedProcess instance
    """
    print(f"?? Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True, check=check)
    
    if result.stdout:
        print(result.stdout)
    if result.stderr:
        print(result.stderr, file=sys.stderr)
    
    return result


def find_project_root() -> Optional[Path]:
    """Find the project root directory."""
    current = Path.cwd()
    
    while current != current.parent:
        if (current / 'pyproject.toml').exists():
            return current
        current = current.parent
    
    return None


def build_package(project_root: Path) -> bool:
    """Build Python package distributions.
    
    Args:
        project_root: Project root directory
        
    Returns:
        True if build successful, False otherwise
    """
    print("?? Building Python package...")
    
    try:
        # Clean previous builds
        dist_dir = project_root / 'dist'
        if dist_dir.exists():
            print("?? Cleaning previous build artifacts...")
            for item in dist_dir.iterdir():
                item.unlink()
        else:
            dist_dir.mkdir(parents=True, exist_ok=True)
        
        # Build package using uv
        result = run_command(['uv', 'build'], check=False)
        
        if result.returncode != 0:
            print("? Build failed", file=sys.stderr)
            return False
        
        # Verify build artifacts
        wheels = list(dist_dir.glob('*.whl'))
        sdists = list(dist_dir.glob('*.tar.gz'))
        
        if not wheels and not sdists:
            print("? No build artifacts found", file=sys.stderr)
            return False
        
        print(f"? Build successful:")
        for artifact in wheels + sdists:
            print(f"   - {artifact.name}")
        
        return True
        
    except Exception as e:
        print(f"? Build error: {e}", file=sys.stderr)
        return False


def check_package(project_root: Path) -> bool:
    """Check package distributions using twine.
    
    Args:
        project_root: Project root directory
        
    Returns:
        True if check passed, False otherwise
    """
    print("?? Checking package distributions...")
    
    try:
        dist_dir = project_root / 'dist'
        result = run_command(['twine', 'check', str(dist_dir / '*')], check=False)
        
        if result.returncode != 0:
            print("? Package check failed", file=sys.stderr)
            return False
        
        print("? Package check passed")
        return True
        
    except Exception as e:
        print(f"? Check error: {e}", file=sys.stderr)
        return False


def publish_to_pypi(project_root: Path, token: str, max_retries: int = 3) -> bool:
    """Publish package to PyPI with retry logic.
    
    Args:
        project_root: Project root directory
        token: PyPI API token
        max_retries: Maximum number of retry attempts
        
    Returns:
        True if published successfully, False otherwise
    """
    print(f"?? Publishing to PyPI (max {max_retries} retries)...")
    
    dist_dir = project_root / 'dist'
    
    for attempt in range(1, max_retries + 1):
        try:
            print(f"?? Attempt {attempt}/{max_retries}...")
            
            # Set up authentication
            env = os.environ.copy()
            env['TWINE_USERNAME'] = '__token__'
            env['TWINE_PASSWORD'] = token
            
            # Upload to PyPI
            result = subprocess.run(
                ['twine', 'upload', '--non-interactive', str(dist_dir / '*')],
                env=env,
                capture_output=True,
                text=True,
                check=False
            )
            
            if result.stdout:
                print(result.stdout)
            if result.stderr:
                print(result.stderr, file=sys.stderr)
            
            if result.returncode == 0:
                print("? Published to PyPI successfully!")
                return True
            
            # Check if it's a retry-able error
            if 'already exists' in result.stderr:
                print("??  Package version already exists on PyPI")
                return True  # Not a failure
            
            if attempt < max_retries:
                wait_time = 2 ** attempt  # Exponential backoff
                print(f"? Waiting {wait_time}s before retry...")
                time.sleep(wait_time)
            
        except Exception as e:
            print(f"? Upload error: {e}", file=sys.stderr)
            if attempt < max_retries:
                wait_time = 2 ** attempt
                print(f"? Waiting {wait_time}s before retry...")
                time.sleep(wait_time)
    
    print("? Failed to publish after all retries", file=sys.stderr)
    return False


def main() -> int:
    """Main entry point for PyPI publishing.
    
    Returns:
        Exit code: 0 for success, 1 for failure
    """
    dry_run = os.getenv('DRY_RUN', 'false').lower() == 'true' or '--dry-run' in sys.argv
    
    if dry_run:
        print("?? DRY RUN MODE - No actual publishing will occur")
        print()
    
    # Find project root
    project_root = find_project_root()
    
    if project_root is None:
        print("? Could not find project root (no pyproject.toml found)", file=sys.stderr)
        return 1
    
    print(f"?? Project root: {project_root}")
    print()
    
    # Build package
    if not build_package(project_root):
        return 1
    
    print()
    
    # Check package
    if not check_package(project_root):
        return 1
    
    print()
    
    # Publish to PyPI (unless dry-run)
    if dry_run:
        print("? Dry run complete - package is ready for publishing")
        return 0
    
    # Get PyPI token
    pypi_token = os.getenv('PYPI_TOKEN')
    
    if not pypi_token:
        print("? PYPI_TOKEN environment variable not set", file=sys.stderr)
        print("   Configure it in GitHub Secrets: Settings ? Secrets ? Actions", file=sys.stderr)
        return 1
    
    # Publish
    if not publish_to_pypi(project_root, pypi_token):
        return 1
    
    print()
    print("? PyPI publishing complete!")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
{% endif %}
