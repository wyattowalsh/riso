{% if changelog_module == "enabled" -%}
#!/usr/bin/env python3
"""Install Git hooks for commit message validation.

This script installs a commit-msg hook that validates commit messages against
the conventional commits specification. The installation is idempotent and
backs up existing hooks.

Usage:
    python install-hooks.py [--force]
    
Options:
    --force: Overwrite existing hooks without backup

Generated by Riso template - Feature 014: Changelog & Release Management
"""

import os
import shutil
import stat
import sys
from pathlib import Path
from typing import Optional


def find_git_root() -> Optional[Path]:
    """Find the root of the Git repository.
    
    Returns:
        Path to Git root, or None if not in a Git repository
    """
    current = Path.cwd()
    
    while current != current.parent:
        git_dir = current / '.git'
        if git_dir.exists():
            return current
        current = current.parent
    
    return None


def backup_existing_hook(hook_path: Path) -> None:
    """Backup an existing Git hook.
    
    Args:
        hook_path: Path to the hook file
    """
    if not hook_path.exists():
        return
    
    backup_path = hook_path.with_suffix('.backup')
    counter = 1
    
    while backup_path.exists():
        backup_path = hook_path.with_name(f"{hook_path.name}.backup.{counter}")
        counter += 1
    
    shutil.copy2(hook_path, backup_path)
    print(f"? Backed up existing hook to: {backup_path.name}")


def install_commit_msg_hook(git_root: Path, force: bool = False) -> bool:
    """Install the commit-msg hook.
    
    Args:
        git_root: Path to Git repository root
        force: Whether to overwrite existing hooks without backup
        
    Returns:
        True if installation successful, False otherwise
    """
    hooks_dir = git_root / '.git' / 'hooks'
    hook_path = hooks_dir / 'commit-msg'
    validator_path = git_root / 'scripts' / 'release' / 'validate-commit.py'
    
    # Ensure hooks directory exists
    hooks_dir.mkdir(parents=True, exist_ok=True)
    
    # Check if validator script exists
    if not validator_path.exists():
        print(f"? Error: Validator script not found: {validator_path}", file=sys.stderr)
        print("   Make sure you're running this from the project root.", file=sys.stderr)
        return False
    
    # Check if hook already installed
    if hook_path.exists():
        # Read existing hook content
        existing_content = hook_path.read_text(encoding='utf-8')
        
        # Check if it's our hook (contains validate-commit.py reference)
        if 'validate-commit.py' in existing_content:
            print("? Commit hook already installed (up to date)")
            return True
        
        # Different hook exists
        if not force:
            print("??  Existing commit-msg hook found")
            backup_existing_hook(hook_path)
    
    # Hook script content
    hook_content = f'''#!/usr/bin/env bash
# Git commit-msg hook for conventional commit validation
# Generated by Riso template - Feature 014: Changelog & Release Management

# Get the commit message file
COMMIT_MSG_FILE="$1"

# Validate commit message using Python script
python3 scripts/release/validate-commit.py "$COMMIT_MSG_FILE"

# Exit with validator's exit code
exit $?
'''
    
    # Write hook file
    hook_path.write_text(hook_content, encoding='utf-8')
    
    # Make executable
    hook_path.chmod(hook_path.stat().st_mode | stat.S_IEXEC | stat.S_IXGRP | stat.S_IXOTH)
    
    print(f"? Installed commit-msg hook: {hook_path}")
    
    return True


def verify_installation(git_root: Path) -> bool:
    """Verify that the hook is properly installed.
    
    Args:
        git_root: Path to Git repository root
        
    Returns:
        True if hook is properly installed, False otherwise
    """
    hook_path = git_root / '.git' / 'hooks' / 'commit-msg'
    
    if not hook_path.exists():
        print("? Verification failed: Hook file does not exist", file=sys.stderr)
        return False
    
    # Check if executable
    if not os.access(hook_path, os.X_OK):
        print("? Verification failed: Hook is not executable", file=sys.stderr)
        return False
    
    # Check content
    content = hook_path.read_text(encoding='utf-8')
    if 'validate-commit.py' not in content:
        print("? Verification failed: Hook does not reference validator", file=sys.stderr)
        return False
    
    print("? Hook installation verified")
    return True


def main() -> int:
    """Main entry point for hook installation.
    
    Returns:
        Exit code: 0 for success, 1 for failure
    """
    # Parse arguments
    force = '--force' in sys.argv
    
    # Find Git root
    git_root = find_git_root()
    
    if git_root is None:
        print("? Error: Not in a Git repository", file=sys.stderr)
        print("   Run this command from your project root.", file=sys.stderr)
        return 1
    
    print(f"?? Git repository: {git_root}")
    print("?? Installing Git hooks for commit validation...")
    print()
    
    # Install commit-msg hook
    if not install_commit_msg_hook(git_root, force=force):
        return 1
    
    # Verify installation
    if not verify_installation(git_root):
        return 1
    
    print()
    print("? Git hooks installed successfully!")
    print()
    print("Next steps:")
    print("  1. Make a commit with conventional format:")
    print("     git commit -m 'feat: add new feature'")
    print()
    print("  2. The hook will validate your commit message")
    print("  3. Invalid commits will be rejected with helpful errors")
    print()
    print("See: https://www.conventionalcommits.org/")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
{% endif %}
