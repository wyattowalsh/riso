{% if changelog_module == "enabled" -%}
#!/usr/bin/env python3
"""Validate commit messages against conventional commit format.

This script validates commit messages to ensure they follow the conventional
commits specification. It detects breaking changes, validates commit types,
and provides helpful error messages.

Usage:
    python validate-commit.py <commit-message-file>
    
Exit codes:
    0: Valid commit message
    1: Invalid commit message

Generated by Riso template - Feature 014: Changelog & Release Management
"""

import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


@dataclass
class CommitMessage:
    """Parsed conventional commit message."""
    
    type: str
    scope: Optional[str]
    subject: str
    body: Optional[str]
    footer: Optional[str]
    breaking: bool
    breaking_change_description: Optional[str] = None


# Conventional commit types
ALLOWED_TYPES = {
    "feat": "A new feature",
    "fix": "A bug fix",
    "docs": "Documentation only changes",
    "chore": "Other changes that don't modify src or test files",
    "refactor": "A code change that neither fixes a bug nor adds a feature",
    "test": "Adding missing tests or correcting existing tests",
    "perf": "A code change that improves performance",
    "ci": "Changes to CI configuration files and scripts",
    "build": "Changes that affect the build system or external dependencies",
    "revert": "Reverts a previous commit",
}

# Scope pattern (alphanumeric and hyphens only)
SCOPE_PATTERN = r"^[a-z0-9-]+$"

# Maximum subject length
MAX_SUBJECT_LENGTH = 72


def parse_commit_message(message: str) -> Optional[CommitMessage]:
    """Parse a conventional commit message.
    
    Args:
        message: The commit message text
        
    Returns:
        CommitMessage object if valid format, None otherwise
    """
    lines = message.strip().split('\n')
    if not lines:
        return None
    
    header = lines[0]
    body_lines = []
    footer_lines = []
    
    # Separate body and footer
    in_footer = False
    for i, line in enumerate(lines[1:], start=1):
        if line.strip() == '':
            continue
        
        # Footer starts with BREAKING CHANGE or specific footer tokens
        if re.match(r'^(BREAKING CHANGE|BREAKING-CHANGE|[A-Z][A-Za-z-]+):', line):
            in_footer = True
        
        if in_footer:
            footer_lines.append(line)
        else:
            body_lines.append(line)
    
    body = '\n'.join(body_lines).strip() if body_lines else None
    footer = '\n'.join(footer_lines).strip() if footer_lines else None
    
    # Parse header: type(scope)!: subject
    header_pattern = r'^(?P<type>[a-z]+)(?:\((?P<scope>[a-z0-9-]+)\))?(?P<breaking>!)?:\s*(?P<subject>.+)$'
    match = re.match(header_pattern, header)
    
    if not match:
        return None
    
    commit_type = match.group('type')
    scope = match.group('scope')
    breaking_exclamation = match.group('breaking') == '!'
    subject = match.group('subject')
    
    # Check for BREAKING CHANGE in footer
    breaking_in_footer = False
    breaking_change_description = None
    if footer:
        breaking_match = re.search(
            r'BREAKING[ -]CHANGE:\s*(.+)',
            footer,
            re.MULTILINE | re.DOTALL
        )
        if breaking_match:
            breaking_in_footer = True
            breaking_change_description = breaking_match.group(1).strip()
    
    breaking = breaking_exclamation or breaking_in_footer
    
    return CommitMessage(
        type=commit_type,
        scope=scope,
        subject=subject,
        body=body,
        footer=footer,
        breaking=breaking,
        breaking_change_description=breaking_change_description
    )


def validate_commit_message(commit: CommitMessage) -> tuple[bool, list[str]]:
    """Validate a parsed commit message.
    
    Args:
        commit: Parsed commit message
        
    Returns:
        Tuple of (is_valid, error_messages)
    """
    errors = []
    
    # Validate type
    if commit.type not in ALLOWED_TYPES:
        errors.append(
            f"Invalid type '{commit.type}'. Allowed types: {', '.join(ALLOWED_TYPES.keys())}"
        )
    
    # Validate scope (if present)
    if commit.scope and not re.match(SCOPE_PATTERN, commit.scope):
        errors.append(
            f"Invalid scope '{commit.scope}'. Scope must contain only lowercase letters, numbers, and hyphens."
        )
    
    # Validate subject
    if not commit.subject:
        errors.append("Subject is required and cannot be empty.")
    elif len(commit.subject) > MAX_SUBJECT_LENGTH:
        errors.append(
            f"Subject is too long ({len(commit.subject)} characters). Maximum is {MAX_SUBJECT_LENGTH}."
        )
    elif commit.subject.endswith('.'):
        errors.append("Subject must not end with a period.")
    elif commit.subject[0].isupper():
        errors.append("Subject must start with a lowercase letter.")
    
    # Validate breaking changes
    if commit.breaking and not commit.breaking_change_description:
        errors.append(
            "Breaking changes must include a BREAKING CHANGE footer with migration notes."
        )
    
    return len(errors) == 0, errors


def format_error_message(errors: list[str]) -> str:
    """Format validation errors into a helpful message.
    
    Args:
        errors: List of error messages
        
    Returns:
        Formatted error message with examples
    """
    message = [
        "? Commit message does not follow conventional format",
        "",
        "Errors:",
    ]
    
    for error in errors:
        message.append(f"  ? {error}")
    
    message.extend([
        "",
        "Expected format:",
        "  <type>(<scope>): <subject>",
        "",
        "  [optional body]",
        "",
        "  [optional footer]",
        "",
        "Examples:",
        "  ? feat(api): add user authentication",
        "  ? fix(cli): correct argument parsing",
        "  ? docs: update README with examples",
        "",
        "For breaking changes:",
        "  ? feat!: redesign authentication API",
        "  ",
        "  BREAKING CHANGE: Auth endpoints now require OAuth2 tokens.",
        "  Migration: Update client code to use new OAuth2 flow.",
        "",
        f"Allowed types: {', '.join(ALLOWED_TYPES.keys())}",
        "",
        "See: https://www.conventionalcommits.org/",
    ])
    
    return '\n'.join(message)


def main() -> int:
    """Main entry point for commit message validation.
    
    Returns:
        Exit code: 0 for valid, 1 for invalid
    """
    if len(sys.argv) < 2:
        print("Usage: validate-commit.py <commit-message-file>", file=sys.stderr)
        return 1
    
    commit_msg_file = Path(sys.argv[1])
    
    if not commit_msg_file.exists():
        print(f"Error: Commit message file not found: {commit_msg_file}", file=sys.stderr)
        return 1
    
    message = commit_msg_file.read_text(encoding='utf-8')
    
    # Skip validation for merge commits
    if message.startswith('Merge '):
        return 0
    
    # Skip validation for revert commits (they have special format)
    if message.startswith('Revert '):
        return 0
    
    # Parse commit message
    commit = parse_commit_message(message)
    
    if commit is None:
        print(format_error_message([
            "Unable to parse commit message",
            "Message must start with type, optional scope, and subject"
        ]), file=sys.stderr)
        return 1
    
    # Validate commit message
    is_valid, errors = validate_commit_message(commit)
    
    if not is_valid:
        print(format_error_message(errors), file=sys.stderr)
        return 1
    
    # Success
    emoji = "??" if commit.breaking else "?"
    print(f"{emoji} Valid commit: {commit.type}", end='')
    if commit.scope:
        print(f"({commit.scope})", end='')
    print(f": {commit.subject}")
    
    if commit.breaking:
        print("??  This is a BREAKING CHANGE - will trigger MAJOR version bump")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
{% endif %}
