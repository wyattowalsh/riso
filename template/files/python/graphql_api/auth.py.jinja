"""Authentication & Authorization for GraphQL."""

from typing import Callable, Any
from functools import wraps

import strawberry
from strawberry.types import Info

from {{ package_name }}.graphql_api.errors import AuthError


def auth_required(func: Callable) -> Callable:
    """
    Decorator for requiring authentication on GraphQL fields.
    
    Usage:
        @strawberry.mutation
        @auth_required
        async def create_user(self, info: Info, ...) -> User:
            # Only authenticated users can execute this
            ...
    
    Args:
        func: Resolver function to wrap
    
    Returns:
        Wrapped resolver that checks authentication
    
    Raises:
        AuthError: If user is not authenticated
    """
    @wraps(func)
    async def wrapper(*args, **kwargs) -> Any:
        # Extract info from args or kwargs
        info: Info = kwargs.get("info") or args[1]
        
        # Check if user is authenticated
        if not info.context.current_user:
            raise AuthError("Authentication required to perform this operation")
        
        # Call original resolver
        return await func(*args, **kwargs)
    
    return wrapper


def permission_required(permission: str) -> Callable:
    """
    Decorator for requiring specific permissions on GraphQL fields.
    
    Usage:
        @strawberry.mutation
        @permission_required("user:write")
        async def create_user(self, info: Info, ...) -> User:
            # Only users with "user:write" permission can execute this
            ...
    
    Args:
        permission: Required permission string
    
    Returns:
        Decorator function
    
    Raises:
        AuthError: If user doesn't have required permission
    """
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> Any:
            # Extract info from args or kwargs
            info: Info = kwargs.get("info") or args[1]
            
            # Check if user is authenticated
            if not info.context.current_user:
                raise AuthError("Authentication required")
            
            # Check permissions (example - customize based on your auth system)
            user_permissions = info.context.current_user.get("permissions", [])
            if permission not in user_permissions:
                raise AuthError(
                    f"Insufficient permissions. Required: {permission}"
                )
            
            # Call original resolver
            return await func(*args, **kwargs)
        
        return wrapper
    
    return decorator


async def get_current_user_from_token(token: str) -> dict:
    """
    Extract and validate user from authentication token.

    Implements JWT validation using python-jose. Configure your SECRET_KEY
    and ALGORITHM in environment variables or configuration.

    Args:
        token: Authentication token (JWT)

    Returns:
        User dictionary with id, email, permissions, etc.

    Raises:
        AuthError: If token is invalid or expired
    """
    import os
    from jose import jwt, JWTError
    from datetime import datetime, timezone

    # Load configuration from environment
    SECRET_KEY = os.getenv("JWT_SECRET_KEY")
    if not SECRET_KEY:
        raise AuthError(
            "JWT_SECRET_KEY not configured. Set this environment variable before using authentication."
        )

    ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")

    try:
        # Decode and validate JWT token
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])

        # Validate expiration
        exp = payload.get("exp")
        if exp is None:
            raise AuthError("Token missing expiration claim")

        if datetime.fromtimestamp(exp, tz=timezone.utc) < datetime.now(timezone.utc):
            raise AuthError("Token has expired")

        # Extract user information
        user_id = payload.get("sub")  # 'sub' is standard JWT claim for user ID
        if not user_id:
            raise AuthError("Token missing subject claim")

        # NOTE: In production, you should fetch the user from your database here
        # to get current permissions and ensure the user still exists
        # Example:
        # async with get_db_session() as db:
        #     user = await db.get(User, user_id)
        #     if not user:
        #         raise AuthError("User not found")
        #     return {
        #         "id": user.id,
        #         "email": user.email,
        #         "permissions": user.permissions,
        #     }

        # For now, return user info from token
        return {
            "id": user_id,
            "email": payload.get("email", ""),
            "permissions": payload.get("permissions", []),
            "username": payload.get("username", ""),
        }

    except JWTError as e:
        raise AuthError(f"Invalid authentication token: {str(e)}")
    except Exception as e:
        raise AuthError(f"Authentication error: {str(e)}")
