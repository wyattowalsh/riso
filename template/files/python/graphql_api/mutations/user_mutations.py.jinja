"""User Mutation Resolvers - Create, update, delete users."""

from typing import Optional
import strawberry
from pydantic import EmailStr, ValidationError as PydanticValidationError

from {{ package_name }}.graphql_api.types.user import (
    User,
    CreateUserInput,
    UpdateUserInput,
)
from {{ package_name }}.graphql_api.errors import ValidationError


@strawberry.type
class UserMutations:
    """User-related mutation operations."""
    
    @strawberry.mutation
    async def create_user(
        self,
        info: strawberry.Info,
        input: CreateUserInput,
    ) -> User:
        """
        Create a new user.
        
        Demonstrates:
        - Input validation with Pydantic
        - Error handling for invalid data
        - Flexible response field selection
        - Authentication (TODO: add @auth decorator)
        
        Args:
            info: GraphQL context
            input: User creation data
        
        Returns:
            Created User
        
        Raises:
            ValidationError: If input validation fails
        """
        # Validate email format
        try:
            from pydantic import BaseModel, field_validator
            
            class EmailValidator(BaseModel):
                email: str
                
                @field_validator("email")
                @classmethod
                def validate_email(cls, v: str) -> str:
                    if "@" not in v or "." not in v:
                        raise ValueError("Invalid email format")
                    return v
            
            EmailValidator(email=input.email)
        except (ValueError, PydanticValidationError) as e:
            raise ValidationError(
                message="Email format is invalid",
                field="email",
            ) from e
        
        # This is a placeholder implementation
        # In a real app, this would save to database:
        # db = info.context.db
        # user_model = UserModel(name=input.name, email=input.email, avatar=input.avatar)
        # db.add(user_model)
        # await db.commit()
        # await db.refresh(user_model)
        # return User.from_orm(user_model)
        
        # Mock implementation
        import uuid
        
        new_user = User(
            id=str(uuid.uuid4()),
            name=input.name,
            email=input.email,
            avatar=input.avatar,
        )
        
        return new_user
    
    @strawberry.mutation
    async def update_user(
        self,
        info: strawberry.Info,
        id: strawberry.ID,
        input: UpdateUserInput,
    ) -> Optional[User]:
        """
        Update an existing user.
        
        Only updates fields provided in input (partial updates supported).
        
        Args:
            info: GraphQL context
            id: User ID to update
            input: Fields to update
        
        Returns:
            Updated User or None if not found
        
        Raises:
            ValidationError: If input validation fails
        """
        # Validate email if provided
        if input.email:
            try:
                from pydantic import BaseModel, field_validator
                
                class EmailValidator(BaseModel):
                    email: str
                    
                    @field_validator("email")
                    @classmethod
                    def validate_email(cls, v: str) -> str:
                        if "@" not in v or "." not in v:
                            raise ValueError("Invalid email format")
                        return v
                
                EmailValidator(email=input.email)
            except (ValueError, PydanticValidationError) as e:
                raise ValidationError(
                    message="Email format is invalid",
                    field="email",
                ) from e
        
        # This is a placeholder implementation
        # In a real app, this would update database:
        # db = info.context.db
        # result = await db.execute(
        #     select(UserModel).where(UserModel.id == id)
        # )
        # user_model = result.scalar_one_or_none()
        # if not user_model:
        #     return None
        # if input.name is not None:
        #     user_model.name = input.name
        # if input.email is not None:
        #     user_model.email = input.email
        # if input.avatar is not None:
        #     user_model.avatar = input.avatar
        # await db.commit()
        # await db.refresh(user_model)
        # return User.from_orm(user_model)
        
        # Mock implementation - fetch existing user
        mock_users = {
            "1": User(
                id="1",
                name="Alice Johnson",
                email="alice@example.com",
                avatar="https://example.com/alice.jpg",
            ),
            "2": User(
                id="2",
                name="Bob Smith",
                email="bob@example.com",
                avatar=None,
            ),
        }
        
        user = mock_users.get(id)
        if not user:
            return None
        
        # Update fields if provided
        if input.name is not None:
            user.name = input.name
        if input.email is not None:
            user.email = input.email
        if input.avatar is not None:
            user.avatar = input.avatar
        
        return user
    
    @strawberry.mutation
    async def delete_user(
        self,
        info: strawberry.Info,
        id: strawberry.ID,
    ) -> bool:
        """
        Delete a user.
        
        Args:
            info: GraphQL context
            id: User ID to delete
        
        Returns:
            True if deleted, False if not found
        """
        # This is a placeholder implementation
        # In a real app, this would delete from database:
        # db = info.context.db
        # result = await db.execute(
        #     select(UserModel).where(UserModel.id == id)
        # )
        # user_model = result.scalar_one_or_none()
        # if not user_model:
        #     return False
        # await db.delete(user_model)
        # await db.commit()
        # return True
        
        # Mock implementation
        mock_existing_ids = {"1", "2", "3"}
        return id in mock_existing_ids
