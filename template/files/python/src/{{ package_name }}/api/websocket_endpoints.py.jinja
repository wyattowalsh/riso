{% if websocket_module == "enabled" and api_tracks in ["python", "python+node"] -%}
"""Example WebSocket endpoints demonstrating basic usage."""

import uuid
from datetime import datetime, timezone
from typing import Any, Dict

from fastapi import FastAPI, WebSocket, WebSocketDisconnect
from loguru import logger

from {{ package_name }}.websocket import ConnectionManager
from {{ package_name }}.websocket.decorators import websocket_endpoint
from {{ package_name }}.websocket.exceptions import WebSocketError
from {{ package_name }}.websocket.models import MessageType
from {{ package_name }}.websocket.utils import format_error_message, generate_message_id


def setup_websocket_routes(app: FastAPI) -> None:
    """
    Configure WebSocket routes for the FastAPI application.

    Args:
        app: FastAPI application instance
    """
    manager = ConnectionManager()

    @app.websocket("/ws")
    async def websocket_basic_endpoint(websocket: WebSocket):
        """
        Basic WebSocket endpoint with connection lifecycle management.

        Demonstrates:
        - Connection establishment with welcome message
        - Echo server functionality
        - Room join/leave operations
        - Broadcasting to rooms
        - Graceful disconnection handling

        Connection URL: ws://localhost:8000/ws
        """
        connection_id = await manager.connect(websocket)

        try:
            # Send welcome message
            welcome_msg = {
                "type":       MessageType.CONNECTION_CONNECT.value,
                "message_id": generate_message_id(),
                "timestamp":  datetime.now(timezone.utc).isoformat(),
                "sender_id":  "server",
                "payload":    {
                    "connection_id":     connection_id,
                    "server_time":       datetime.now(timezone.utc).isoformat(),
                    "heartbeat_interval": manager.config.heartbeat_interval,
                    "message":           "Welcome to the WebSocket server!",
                },
            }
            connection = manager.get_connection(connection_id)
            if connection:
                await connection.send_json(welcome_msg)

            # Message handling loop
            while True:
                try:
                    # Receive message
                    data = await websocket.receive_json()

                    # Handle different message types
                    message_type = data.get("type")

                    if message_type == "message.text":
                        # Echo text message
                        response = {
                            "type":          MessageType.MESSAGE_TEXT.value,
                            "message_id":    generate_message_id(),
                            "timestamp":     datetime.now(timezone.utc).isoformat(),
                            "sender_id":     "server",
                            "correlation_id": data.get("message_id"),
                            "payload":       {
                                "text": f"Echo: {data['payload']['text']}",
                            },
                        }
                        if connection:
                            await connection.send_json(response)

                    elif message_type == "room.join":
                        # Join room
                        room_id = data["payload"]["room_id"]
                        await manager.join_room(connection_id, room_id)

                        # Send join confirmation
                        join_response = {
                            "type":          MessageType.ROOM_JOINED.value,
                            "message_id":    generate_message_id(),
                            "timestamp":     datetime.now(timezone.utc).isoformat(),
                            "sender_id":     "server",
                            "correlation_id": data.get("message_id"),
                            "payload":       {
                                "room_id":      room_id,
                                "member_count": len(manager.get_connections_by_room(room_id)),
                            },
                        }
                        if connection:
                            await connection.send_json(join_response)

                        # Notify other room members
                        member_joined_msg = {
                            "type":       MessageType.ROOM_MEMBER_JOINED.value,
                            "message_id": generate_message_id(),
                            "timestamp":  datetime.now(timezone.utc).isoformat(),
                            "sender_id":  "server",
                            "payload":    {
                                "room_id":       room_id,
                                "connection_id": connection_id,
                                "member_count":  len(manager.get_connections_by_room(room_id)),
                            },
                        }
                        await manager.broadcast_to_room(
                            room_id,
                            member_joined_msg,
                            exclude_sender=connection_id,
                        )

                    elif message_type == "room.leave":
                        # Leave room
                        room_id = data["payload"]["room_id"]
                        await manager.leave_room(connection_id, room_id)

                        # Send leave confirmation
                        leave_response = {
                            "type":          MessageType.ROOM_LEFT.value,
                            "message_id":    generate_message_id(),
                            "timestamp":     datetime.now(timezone.utc).isoformat(),
                            "sender_id":     "server",
                            "correlation_id": data.get("message_id"),
                            "payload":       {
                                "room_id":      room_id,
                                "member_count": len(manager.get_connections_by_room(room_id)),
                            },
                        }
                        if connection:
                            await connection.send_json(leave_response)

                    elif message_type == "room.broadcast":
                        # Broadcast to room
                        room_id = data["payload"]["room_id"]
                        broadcast_message = data["payload"]["message"]
                        exclude_sender = data["payload"].get("exclude_sender", False)

                        # Add metadata
                        broadcast_message["sender_id"] = connection_id
                        broadcast_message["message_id"] = generate_message_id()
                        broadcast_message["timestamp"] = datetime.now(timezone.utc).isoformat()

                        # Broadcast
                        await manager.broadcast_to_room(
                            room_id,
                            broadcast_message,
                            exclude_sender=connection_id if exclude_sender else None,
                        )

                    elif message_type == "heartbeat.pong":
                        # Handle heartbeat pong
                        logger.debug(
                            f"Received heartbeat pong from {connection_id}",
                            extra={
                                "connection_id":  connection_id,
                                "ping_message_id": data["payload"].get("ping_message_id"),
                            },
                        )

                    else:
                        # Unknown message type
                        error_msg = format_error_message(
                            code="INVALID_FORMAT",
                            message=f"Unknown message type: {message_type}",
                            details={"type": message_type},
                        )
                        if connection:
                            await connection.send_json(error_msg)

                except WebSocketError as e:
                    # Send structured error response
                    error_msg = format_error_message(
                        code=e.code,
                        message=e.message,
                        details=e.details,
                    )
                    if connection:
                        await connection.send_json(error_msg)

                except Exception as e:
                    # Log unexpected errors
                    logger.error(
                        f"Error processing WebSocket message: {e}",
                        exc_info=True,
                        extra={"connection_id": connection_id},
                    )
                    error_msg = format_error_message(
                        code="INTERNAL_ERROR",
                        message="Internal server error",
                    )
                    if connection:
                        await connection.send_json(error_msg)

        except WebSocketDisconnect:
            logger.info(
                f"WebSocket client disconnected: {connection_id}",
                extra={"connection_id": connection_id},
            )

        finally:
            # Clean up connection
            await manager.disconnect(connection_id)

    @app.websocket("/ws/echo")
    async def websocket_echo_endpoint(websocket: WebSocket):
        """
        Simple echo WebSocket endpoint.

        Echoes back any message received.
        Useful for testing and debugging.

        Connection URL: ws://localhost:8000/ws/echo
        """
        connection_id = await manager.connect(websocket)

        try:
            while True:
                # Receive and echo back
                data = await websocket.receive_text()

                connection = manager.get_connection(connection_id)
                if connection:
                    await connection.send_text(f"Echo: {data}")

        except WebSocketDisconnect:
            pass
        finally:
            await manager.disconnect(connection_id)


# Example: Integrate with FastAPI app
# from {{ package_name }}.api.websocket_endpoints import setup_websocket_routes
# setup_websocket_routes(app)
{% endif -%}
