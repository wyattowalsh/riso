{%- if api_tracks | lower not in ["python", "python+node"] %}
"""Error handling middleware - disabled for this render."""
{%- else %}
"""Global error handling middleware.

Provides consistent error responses across the API.
Catches unhandled exceptions and returns structured error responses.
"""
from __future__ import annotations

import logging
import traceback
import uuid
from typing import Any

from fastapi import FastAPI, Request, status
from fastapi.exceptions import HTTPException, RequestValidationError
from fastapi.responses import JSONResponse

from {{ package_name }}.api.config import Settings
from {{ package_name }}.api.models.responses import ErrorResponse

logger = logging.getLogger(__name__)


def configure_error_handlers(app: FastAPI, settings: Settings) -> None:
    """Configure global error handlers on the FastAPI application.
    
    Args:
        app: FastAPI application instance
        settings: Application settings for environment-specific error handling
    """
    
    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(
        request: Request,
        exc: RequestValidationError
    ) -> JSONResponse:
        """Handle Pydantic validation errors (422 status).
        
        Returns detailed field-level validation errors to help clients
        understand what needs to be corrected.
        """
        request_id = str(uuid.uuid4())
        
        # Log validation error
        logger.warning(
            f"Validation error on {request.method} {request.url.path}",
            extra={
                "request_id": request_id,
                "errors": exc.errors(),
                "body": exc.body
            }
        )
        
        error_response = ErrorResponse(
            detail=exc.errors(),
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            request_id=request_id
        )
        
        return JSONResponse(
            status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
            content=error_response.model_dump(),
            headers={"X-Request-ID": request_id}
        )
    
    @app.exception_handler(HTTPException)
    async def http_exception_handler(
        request: Request,
        exc: HTTPException
    ) -> JSONResponse:
        """Handle FastAPI HTTP exceptions (4xx and 5xx status codes).
        
        Wraps HTTP exceptions in consistent error response format.
        """
        request_id = str(uuid.uuid4())
        
        # Log HTTP exception
        if exc.status_code >= 500:
            logger.error(
                f"HTTP {exc.status_code} on {request.method} {request.url.path}: {exc.detail}",
                extra={"request_id": request_id}
            )
        else:
            logger.info(
                f"HTTP {exc.status_code} on {request.method} {request.url.path}: {exc.detail}",
                extra={"request_id": request_id}
            )
        
        error_response = ErrorResponse(
            detail=str(exc.detail),
            status_code=exc.status_code,
            request_id=request_id
        )
        
        return JSONResponse(
            status_code=exc.status_code,
            content=error_response.model_dump(),
            headers={"X-Request-ID": request_id}
        )
    
    @app.exception_handler(Exception)
    async def general_exception_handler(
        request: Request,
        exc: Exception
    ) -> JSONResponse:
        """Handle all uncaught exceptions (500 status).
        
        Provides safe error responses in production (no stack traces exposed).
        Logs full error details for debugging.
        """
        request_id = str(uuid.uuid4())
        
        # Log full exception details
        logger.error(
            f"Unhandled exception on {request.method} {request.url.path}",
            extra={
                "request_id": request_id,
                "exception_type": type(exc).__name__,
                "exception_message": str(exc),
                "traceback": traceback.format_exc()
            },
            exc_info=True
        )
        
        # Safe error message (hide internal details in production)
        if settings.is_production():
            detail = "Internal server error. Please contact support with request ID."
        else:
            detail = f"{type(exc).__name__}: {str(exc)}"
        
        error_response = ErrorResponse(
            detail=detail,
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            request_id=request_id
        )
        
        return JSONResponse(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            content=error_response.model_dump(),
            headers={"X-Request-ID": request_id}
        )
{%- endif %}
