{%- if api_tracks | lower not in ["python", "python+node"] %}
"""FastAPI service disabled for this render."""


def create_app():
    """Placeholder app when the Python API track is not enabled."""
    raise RuntimeError("FastAPI track disabled. Enable with api_tracks=python or python+node.")


app = None
{%- else %}
"""FastAPI application factory and health endpoint wiring."""

from __future__ import annotations

from importlib import import_module
from typing import Any, cast

from fastapi import FastAPI  # type: ignore[import-not-found]
from fastapi.responses import JSONResponse  # type: ignore[import-not-found]
from tenacity import retry, stop_after_attempt, wait_fixed

from .settings import ApiSettings, get_settings
from .health import router as health_router
{%- if rate_limiting_enabled | default(false) %}
from .rate_limit import RateLimitMiddleware, load_config
{%- endif %}

build_health_payload: Any
HealthCheckResult: Any

try:
    _shared_logic = import_module("shared.logic")
except ModuleNotFoundError:  # pragma: no cover - shared logic optional

    class _FallbackHealthCheckResult:
        """Simple health check container used when shared logic is unavailable."""

        def __init__(self, name: str, status: str = "ok") -> None:
            """Initialise the fallback health check representation."""
            self.name = name
            self.status = status

        def as_dict(self) -> dict[str, str]:
            """Return the health check as a serialisable dictionary."""
            return {"name": self.name, "status": self.status}

    def _fallback_build_health_payload(
        service: str,
        *,
        checks: list[dict[str, Any]] | None = None,
        dry_run: bool = False,
    ) -> dict[str, Any]:
        """Construct a minimal health payload when shared logic is unavailable."""
        payload: dict[str, Any] = {"service": service, "status": "ok", "dry_run": dry_run}
        if checks:
            payload["checks"] = list(checks)
        return payload

    HealthCheckResult = _FallbackHealthCheckResult
    build_health_payload = _fallback_build_health_payload
else:
    HealthCheckResult = _shared_logic.HealthCheckResult
    build_health_payload = _shared_logic.build_health_payload

def _configure_app(settings: ApiSettings) -> FastAPI:
    """Create a FastAPI instance using the provided settings."""
    return FastAPI(
        title=f"{settings.service_name} service",
        version="0.1.0",
        docs_url="/docs",
        redoc_url="/redoc",
    )


def _health_checks() -> list[Any]:
    """Return the baseline list of health checks."""
    return [HealthCheckResult(name="application")]  # future modules can append more checks


@retry(
    stop=stop_after_attempt(get_settings().health_retry_attempts),
    wait=wait_fixed(get_settings().health_retry_wait_seconds),
)
def compute_health_payload(settings: ApiSettings) -> dict[str, Any]:
    """Build a health payload, retrying if dependencies fail transiently."""
    checks = [check.as_dict() for check in _health_checks()]
    return build_health_payload(settings.service_name, checks=checks)


def create_app(settings: ApiSettings | None = None) -> FastAPI:
    """Create and configure the FastAPI application."""
    resolved_settings = settings or get_settings()
    app = _configure_app(resolved_settings)

{%- if rate_limiting_enabled | default(false) %}
    # Register rate limiting middleware (before route handlers)
    try:
        rate_limit_config = load_config()
        if rate_limit_config.enabled:
            app.add_middleware(RateLimitMiddleware, config=rate_limit_config)
    except Exception as e:
        import sys
        from loguru import logger
        logger.warning(f"Failed to initialize rate limiting: {e}", exc_info=True)
        if sys.stderr.isatty():
            logger.info("Rate limiting disabled - continuing without it")
{%- endif %}

    # Register containerhealth router (simple /health endpoint for Docker/K8s)
    app.include_router(health_router)

    return app


app = create_app()
{%- endif %}
