{% if codegen_module == 'enabled' %}"""Atomic file operations for all-or-nothing generation.

This module ensures that file generation either completes fully or rolls back
completely, preventing partial project states.
"""

from pathlib import Path
from typing import Optional
import shutil
import os
from loguru import logger


class AtomicFileWriter:
    """Atomic file operations with rollback support."""
    
    def __init__(self, target_dir: Path):
        """Initialize atomic file writer.
        
        Args:
            target_dir: Target directory for file operations
        """
        self.target_dir = target_dir
        self.temp_dir: Optional[Path] = None
        self.created_files: list[Path] = []
        self.original_files: dict[Path, bytes] = {}  # Backup of overwritten files
        logger.debug(f"Atomic file writer initialized for {target_dir}")
    
    def __enter__(self):
        """Enter atomic context - create temp directory."""
        import tempfile
        self.temp_dir = Path(tempfile.mkdtemp(prefix="scaffold_"))
        logger.debug(f"Created temp directory: {self.temp_dir}")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit atomic context - commit or rollback."""
        if exc_type is None:
            # Success - commit changes
            self._commit()
        else:
            # Error - rollback changes
            logger.error(f"Error during generation: {exc_val}")
            self._rollback()
        
        # Clean up temp directory
        if self.temp_dir and self.temp_dir.exists():
            shutil.rmtree(self.temp_dir)
            logger.debug("Cleaned up temp directory")
        
        return False  # Re-raise exception if any
    
    def write_file(
        self,
        relative_path: Path,
        content: str | bytes,
        *,
        preserve_permissions: bool = True,
        source_path: Optional[Path] = None,
    ) -> Path:
        """Write file atomically.
        
        Args:
            relative_path: Path relative to target directory
            content: File content (text or binary)
            preserve_permissions: Copy file permissions from source
            source_path: Source file for permission copying
            
        Returns:
            Path to written file in temp directory
        """
        if not self.temp_dir:
            raise RuntimeError("AtomicFileWriter must be used as context manager")
        
        # Create path in temp directory
        temp_file = self.temp_dir / relative_path
        temp_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Backup existing file if overwriting
        target_file = self.target_dir / relative_path
        if target_file.exists():
            logger.debug(f"Backing up existing file: {relative_path}")
            self.original_files[target_file] = target_file.read_bytes()
        
        # Write content
        if isinstance(content, str):
            temp_file.write_text(content, encoding="utf-8")
        else:
            temp_file.write_bytes(content)
        
        # Preserve permissions if requested
        if preserve_permissions and source_path and source_path.exists():
            mode = source_path.stat().st_mode
            temp_file.chmod(mode)
            logger.debug(f"Preserved permissions {oct(mode)} for {relative_path}")
        
        self.created_files.append(relative_path)
        logger.debug(f"Wrote file to temp: {relative_path}")
        
        return temp_file
    
    def copy_file(
        self,
        source_path: Path,
        relative_path: Path,
        *,
        preserve_permissions: bool = True,
    ) -> Path:
        """Copy file atomically (for binary files).
        
        Args:
            source_path: Source file path
            relative_path: Destination relative path
            preserve_permissions: Preserve file permissions
            
        Returns:
            Path to copied file in temp directory
        """
        content = source_path.read_bytes()
        return self.write_file(
            relative_path,
            content,
            preserve_permissions=preserve_permissions,
            source_path=source_path,
        )
    
    def _commit(self) -> None:
        """Commit all changes from temp to target directory."""
        if not self.temp_dir:
            return
        
        logger.info(f"Committing {len(self.created_files)} files")
        
        # Ensure target directory exists
        self.target_dir.mkdir(parents=True, exist_ok=True)
        
        # Move files from temp to target
        for relative_path in self.created_files:
            temp_file = self.temp_dir / relative_path
            target_file = self.target_dir / relative_path
            
            # Create parent directories
            target_file.parent.mkdir(parents=True, exist_ok=True)
            
            # Move file
            shutil.move(str(temp_file), str(target_file))
            logger.debug(f"Committed: {relative_path}")
        
        logger.info("All files committed successfully")
    
    def _rollback(self) -> None:
        """Rollback all changes."""
        logger.warning(f"Rolling back {len(self.created_files)} files")
        
        # Restore backed up files
        for target_file, original_content in self.original_files.items():
            target_file.write_bytes(original_content)
            logger.debug(f"Restored: {target_file}")
        
        # Delete newly created files
        for relative_path in self.created_files:
            target_file = self.target_dir / relative_path
            if target_file.exists() and target_file not in self.original_files:
                target_file.unlink()
                logger.debug(f"Deleted: {relative_path}")
        
        logger.info("Rollback complete")
    
    def get_stats(self) -> dict:
        """Get statistics about current operation.
        
        Returns:
            Dictionary with file counts and sizes
        """
        total_size = 0
        if self.temp_dir:
            for relative_path in self.created_files:
                temp_file = self.temp_dir / relative_path
                if temp_file.exists():
                    total_size += temp_file.stat().st_size
        
        return {
            "file_count": len(self.created_files),
            "total_size_bytes": total_size,
            "backed_up_count": len(self.original_files),
        }
{% endif %}