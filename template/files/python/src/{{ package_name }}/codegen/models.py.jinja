{% if codegen_module == 'enabled' %}"""Data models for code generation and scaffolding system.

This module defines the core data structures used throughout the scaffolding tool:
- Enums for template types, variable types, merge strategies, etc.
- Core models: Template, Project, Module, etc.
- Value objects: FilePattern, Dependency, HookConfiguration
"""

from __future__ import annotations

from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any

from pydantic import BaseModel, Field, field_validator


# ============================================================================
# Enums
# ============================================================================


class TemplateType(str, Enum):
    """Type of template."""
    PROJECT = "project"      # Full project scaffolding
    MODULE = "module"        # Feature module
    API_SPEC = "api_spec"    # Generated from OpenAPI/GraphQL


class ModuleType(str, Enum):
    """Type of feature module."""
    API = "api"
    CLI = "cli"
    DOCS = "docs"
    AUTH = "auth"
    DATABASE = "database"
    WEBSOCKET = "websocket"
    GRAPHQL = "graphql"
    CUSTOM = "custom"


class VariableType(str, Enum):
    """Variable data type."""
    STRING = "string"
    INT = "int"
    BOOL = "bool"
    CHOICE = "choice"


class OverwriteMode(str, Enum):
    """File conflict handling mode."""
    SKIP = "skip"            # Skip existing files
    OVERWRITE = "overwrite"  # Replace existing files
    MERGE = "merge"          # Three-way merge
    PROMPT = "prompt"        # Ask user for each file


class RegistryType(str, Enum):
    """Template registry storage type."""
    LOCAL = "local"          # Filesystem directory
    GIT = "git"              # Git repository
    HTTP = "http"            # HTTP(S) URL
    CUSTOM = "custom"        # Custom protocol


class MergeStrategy(str, Enum):
    """Strategy for merging template updates."""
    THREE_WAY = "three_way"  # Standard three-way merge
    OURS = "ours"            # Keep user version
    THEIRS = "theirs"        # Keep template version
    UNION = "union"          # Combine both


class QualityStatus(str, Enum):
    """Quality check status."""
    PASS = "pass"            # All checks passed
    WARN = "warn"            # Warnings present, non-blocking
    FAIL = "fail"            # Critical errors found


# ============================================================================
# Value Objects
# ============================================================================


class FilePattern(BaseModel):
    """Pattern for files to generate from template."""
    pattern: str = Field(..., description="Glob pattern (e.g., 'src/**/*.py.jinja')")
    exclude: list[str] = Field(default_factory=list, description="Exclusion patterns")
    preserve_permissions: bool = Field(default=True, description="Copy file mode bits")


class Dependency(BaseModel):
    """Required tool or package for template."""
    name: str = Field(..., description="Tool name (e.g., 'python', 'node')")
    version_constraint: str = Field(..., description="Version spec (e.g., '>=3.11,<4.0')")
    optional: bool = Field(default=False, description="Can be skipped")


class HookConfiguration(BaseModel):
    """Pre/post generation hook scripts."""
    pre_gen: list[str] = Field(default_factory=list, description="Scripts before generation")
    post_gen: list[str] = Field(default_factory=list, description="Scripts after generation")
    timeout_seconds: int = Field(default=10, ge=1, le=300, description="Max execution time")
    env_vars: dict[str, str] = Field(default_factory=dict, description="Environment variables")


class ModificationRecord(BaseModel):
    """Tracks user modification for conflict detection."""
    file_path: Path = Field(..., description="Modified file")
    original_hash: str = Field(..., description="SHA256 of original")
    modified_hash: str = Field(..., description="SHA256 after modification")
    modified_at: datetime = Field(..., description="Modification timestamp")


# ============================================================================
# Core Models
# ============================================================================


class VariableDefinition(BaseModel):
    """Template variable definition."""
    name: str = Field(..., pattern=r"^[a-zA-Z_][a-zA-Z0-9_]*$", description="Variable identifier")
    type: VariableType = Field(..., description="Data type")
    required: bool = Field(default=True, description="Must be provided")
    default: str | int | bool | None = Field(default=None, description="Default value")
    description: str = Field(..., min_length=10, max_length=200, description="Help text")
    pattern: str | None = Field(default=None, description="Regex validation pattern")
    choices: list[str] | None = Field(default=None, description="Valid choices (for choice type)")
    prompt_message: str | None = Field(default=None, description="Interactive prompt text")

    @field_validator("choices")
    @classmethod
    def validate_choices(cls, v: list[str] | None, info) -> list[str] | None:
        """Validate that choice type has choices."""
        if info.data.get("type") == VariableType.CHOICE:
            if not v or len(v) < 2:
                raise ValueError("Choice type requires at least 2 choices")
        return v

    @field_validator("default")
    @classmethod
    def validate_default_in_choices(cls, v: str | int | bool | None, info) -> str | int | bool | None:
        """Validate that default is in choices if both provided."""
        if v is not None and info.data.get("choices"):
            if str(v) not in info.data["choices"]:
                raise ValueError(f"Default value '{v}' must be in choices")
        return v


class Template(BaseModel):
    """Template metadata."""
    name: str = Field(..., pattern=r"^[a-z][a-z0-9-]*$", min_length=3, max_length=50)
    version: str = Field(..., pattern=r"^\d+\.\d+\.\d+$", description="Semantic version")
    description: str = Field(..., min_length=10, max_length=200)
    author: str | None = Field(default=None, description="Template author/maintainer")
    template_type: TemplateType = Field(default=TemplateType.PROJECT)
    source_url: str | None = Field(default=None, description="Remote repository URL")
    local_path: Path = Field(..., description="Local filesystem path")
    size_bytes: int = Field(..., le=104_857_600, description="Total size (100MB max)")
    variables: dict[str, VariableDefinition] = Field(..., description="Template variables")
    file_patterns: list[FilePattern] = Field(default_factory=list, description="Files to generate")
    hooks: HookConfiguration | None = Field(default=None, description="Pre/post hooks")
    dependencies: list[Dependency] = Field(default_factory=list, description="Required tools")
    metadata: dict[str, Any] = Field(default_factory=dict, description="Additional metadata")
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)

    @field_validator("size_bytes")
    @classmethod
    def warn_on_large_size(cls, v: int) -> int:
        """Warn if template exceeds 50MB."""
        if v > 52_428_800:  # 50MB
            from loguru import logger
            logger.warning(f"Template size {v / 1_048_576:.1f}MB exceeds 50MB recommendation")
        return v


class Module(BaseModel):
    """Feature module added to an existing project."""
    name: str = Field(..., pattern=r"^[a-z][a-z0-9_]*$", description="Module identifier")
    module_type: ModuleType = Field(..., description="Type of module")
    template_name: str = Field(..., description="Source template for module")
    template_version: str = Field(..., pattern=r"^\d+\.\d+\.\d+$")
    variables: dict[str, Any] = Field(..., description="Module-specific variables")
    generated_files: list[Path] = Field(default_factory=list, description="Files created")
    modified_files: list[Path] = Field(default_factory=list, description="Existing files updated")
    dependencies_added: list[str] = Field(default_factory=list, description="New packages")
    created_at: datetime = Field(default_factory=datetime.now)


class Project(BaseModel):
    """Generated project created from a template."""
    name: str = Field(..., description="Project name")
    root_path: Path = Field(..., description="Project root directory")
    template_name: str = Field(..., description="Source template identifier")
    template_version: str = Field(..., pattern=r"^\d+\.\d+\.\d+$")
    variables: dict[str, Any] = Field(..., description="Variable values used")
    generated_files: list[Path] = Field(default_factory=list, description="Generated files")
    metadata_file: Path = Field(..., description="Path to .scaffold-metadata.json")
    custom_modifications: list[ModificationRecord] = Field(
        default_factory=list, description="Tracked user changes"
    )
    modules: list[Module] = Field(default_factory=list, description="Added modules")
    quality_status: QualityStatus = Field(default=QualityStatus.PASS)
    created_at: datetime = Field(default_factory=datetime.now)
    last_updated_at: datetime | None = Field(default=None)


class ConflictRegion(BaseModel):
    """Single merge conflict region."""
    start_line: int = Field(..., ge=1, description="Starting line (1-indexed)")
    end_line: int = Field(..., ge=1, description="Ending line (1-indexed)")
    user_content: str = Field(..., description="User's version")
    template_content: str = Field(..., description="Template's version")
    base_content: str | None = Field(default=None, description="Original version")

    @field_validator("end_line")
    @classmethod
    def validate_line_order(cls, v: int, info) -> int:
        """Validate end_line >= start_line."""
        if "start_line" in info.data and v < info.data["start_line"]:
            raise ValueError("end_line must be >= start_line")
        return v


class MergeResult(BaseModel):
    """Result of a three-way merge operation."""
    file_path: Path = Field(..., description="File being merged")
    merged_content: str = Field(..., description="Merged file content")
    has_conflicts: bool = Field(..., description="Whether conflicts exist")
    conflict_count: int = Field(default=0, ge=0, description="Number of conflicts")
    conflict_regions: list[ConflictRegion] = Field(
        default_factory=list, description="Conflict locations"
    )
    merge_strategy: MergeStrategy = Field(..., description="Strategy used")

    @field_validator("conflict_regions")
    @classmethod
    def validate_conflict_consistency(cls, v: list[ConflictRegion], info) -> list[ConflictRegion]:
        """Validate conflict_count matches regions length."""
        if len(v) != info.data.get("conflict_count", 0):
            raise ValueError("conflict_regions length must match conflict_count")
        return v


class TemplateRegistry(BaseModel):
    """Repository or catalog of available templates."""
    name: str = Field(..., description="Registry identifier")
    registry_type: RegistryType = Field(..., description="Storage type")
    location: str = Field(..., description="Registry location (path/URL)")
    templates: list[Template] = Field(default_factory=list, description="Available templates")
    last_sync: datetime | None = Field(default=None, description="Last synchronization")
    cache_dir: Path = Field(..., description="Local cache directory")
{% endif %}