{%- if cli_module | lower != "enabled" %}
"""CLI module disabled.

Re-render the template with `cli_module=enabled` to scaffold the Typer CLI.
"""


def main() -> None:
    """Entry point placeholder when the CLI is not enabled."""
    raise SystemExit("CLI module is disabled for this render.")


if __name__ == "__main__":
    main()
{%- else %}
"""Multi-command CLI with automatic command discovery."""

from __future__ import annotations

import importlib
import sys
from pathlib import Path
from typing import Any

import typer
from loguru import logger

from {{ package_name }}.cli.core import CLIError, get_command_metadata

# Initialize Typer app
app = typer.Typer(
    name="{{ project_name }}",
    help="{{ project_name }} - Command-line interface",
    no_args_is_help=True,
    rich_markup_mode="rich",
    add_completion=True,
)


def discover_commands() -> list[tuple[Any, dict[str, Any]]]:
    """Discover all command modules in the commands directory.
    
    Returns:
        List of (command_function, metadata) tuples
    """
    commands = []
    commands_dir = Path(__file__).parent / "commands"
    
    if not commands_dir.exists():
        logger.warning(f"Commands directory not found: {commands_dir}")
        return commands
    
    # Find all Python files in commands directory
    for file_path in commands_dir.glob("*.py"):
        if file_path.name.startswith("_"):
            continue
        
        module_name = f"{{ package_name }}.cli.commands.{file_path.stem}"
        try:
            module = importlib.import_module(module_name)
            
            # Look for decorated command functions
            for attr_name in dir(module):
                if attr_name.startswith("_"):
                    continue
                
                attr = getattr(module, attr_name)
                if not callable(attr):
                    continue
                
                # Check if it's a command (has our decorator metadata)
                if hasattr(attr, "_cli_command") and attr._cli_command:
                    metadata = get_command_metadata(attr)
                    commands.append((attr, metadata))
                    logger.debug(f"Discovered command: {metadata['name']} from {module_name}")
        
        except Exception as e:
            logger.warning(f"Failed to load command module {module_name}: {e}")
            continue
    
    return commands


def register_commands() -> None:
    """Register all discovered commands with the Typer app."""
    commands = discover_commands()
    
    if not commands:
        logger.warning("No commands discovered")
        return
    
    for cmd_func, metadata in commands:
        # Register primary command name
        cmd_name = metadata.get("name", cmd_func.__name__)
        cmd_help = metadata.get("help", cmd_func.__doc__ or "")
        hidden = metadata.get("hidden", False)
        
        app.command(name=cmd_name, help=cmd_help, hidden=hidden)(cmd_func)
        logger.debug(f"Registered command: {cmd_name}")
        
        # Register aliases if present
        aliases = metadata.get("aliases", [])
        for alias in aliases:
            app.command(name=alias, help=f"Alias for '{cmd_name}'", hidden=True)(cmd_func)
            logger.debug(f"Registered alias: {alias} -> {cmd_name}")


def main() -> None:
    """CLI entry point with error handling."""
    try:
        # Discover and register commands
        register_commands()
        
        # Run the app
        app()
    
    except CLIError as e:
        logger.error(f"CLI error: {e}")
        sys.exit(e.exit_code)
    
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
        sys.exit(130)
    
    except Exception as e:
        logger.exception(f"Unexpected error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
{%- endif %}
