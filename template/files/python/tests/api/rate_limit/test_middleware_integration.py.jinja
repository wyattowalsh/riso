{%- if api_tracks | lower not in ["python", "python+node"] or not rate_limiting_enabled | default(false) %}
"""Middleware integration tests disabled."""
{%- else %}
"""Integration tests for rate limiting middleware with FastAPI."""

from __future__ import annotations

from unittest.mock import AsyncMock, Mock

import pytest
from fastapi import FastAPI
from fastapi.testclient import TestClient

from {{ package_name }}.api.rate_limit import RateLimitConfig, RateLimitMiddleware
from {{ package_name }}.api.rate_limit.backends.memory import MemoryBackend


@pytest.fixture
def app():
    """Create FastAPI app with rate limiting middleware."""
    app = FastAPI()

    # Configure rate limiting
    config = RateLimitConfig(
        enabled=True,
        default_limit=10,
        default_window=60,
        algorithm="token_bucket",
    )

    # Add middleware with memory backend (for testing)
    middleware = RateLimitMiddleware(app, config)
    middleware.backend = MemoryBackend()  # Override with memory backend
    app.add_middleware(type(middleware), config=config)

    # Add test endpoint
    @app.get("/test")
    async def test_endpoint():
        return {"status": "ok"}

    return app


@pytest.fixture
def client(app):
    """Create test client."""
    return TestClient(app)


class TestRateLimitMiddleware:
    """Test rate limiting middleware integration."""

    def test_first_request_allowed(self, client):
        """Test that first request is allowed and includes headers."""
        response = client.get("/test")

        assert response.status_code == 200
        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers
        assert "X-RateLimit-Reset" in response.headers

        assert response.headers["X-RateLimit-Limit"] == "10"
        assert int(response.headers["X-RateLimit-Remaining"]) == 9

    def test_within_limit_requests_allowed(self, client):
        """Test that requests within limit are allowed."""
        for i in range(10):
            response = client.get("/test")
            assert response.status_code == 200
            remaining = int(response.headers["X-RateLimit-Remaining"])
            assert remaining == 10 - i - 1

    def test_exceed_limit_returns_429(self, client):
        """Test that exceeding limit returns HTTP 429."""
        # Make requests up to limit
        for _ in range(10):
            response = client.get("/test")
            assert response.status_code == 200

        # Next request should be rate limited
        response = client.get("/test")

        assert response.status_code == 429
        assert response.headers["X-RateLimit-Remaining"] == "0"
        assert "Retry-After" in response.headers

        # Check JSON error body
        data = response.json()
        assert data["error"] == "rate_limit_exceeded"
        assert "retry_after_seconds" in data

    def test_rate_limit_headers_in_all_responses(self, client):
        """Test that rate limit headers are in all responses (200, 429)."""
        # Success response
        response = client.get("/test")
        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers
        assert "X-RateLimit-Reset" in response.headers

        # Fill limit
        for _ in range(9):
            client.get("/test")

        # 429 response
        response = client.get("/test")
        assert response.status_code == 429
        assert "X-RateLimit-Limit" in response.headers
        assert "X-RateLimit-Remaining" in response.headers
        assert "X-RateLimit-Reset" in response.headers
        assert "Retry-After" in response.headers

    def test_health_endpoint_exempted(self, client):
        """Test that /health endpoint is automatically exempted."""
        # Note: This test would need the actual health endpoint registered
        # For now, just verify the exemption logic
        pass

    def test_different_clients_independent_counters(self, client):
        """Test that different client IPs have independent counters."""
        # Make 10 requests from client 1
        for _ in range(10):
            response = client.get("/test")
            assert response.status_code == 200

        # Client 1 should be rate limited
        response = client.get("/test")
        assert response.status_code == 429

        # Client 2 (different IP) should still be allowed
        # Note: TestClient doesn't easily allow changing client IP
        # This would need a real integration test with multiple clients
        pass
{%- endif %}
