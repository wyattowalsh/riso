{% if codegen_module == 'enabled' %}"""Tests for data models."""

import pytest
from datetime import datetime
from pathlib import Path
from pydantic import ValidationError

from {{ package_name }}.codegen.models import (
    VariableDefinition,
    VariableType,
    Template,
    TemplateType,
    Project,
    Module,
    ModuleType,
    ConflictRegion,
    MergeResult,
    MergeStrategy,
    QualityStatus,
)


class TestVariableDefinition:
    """Tests for VariableDefinition model."""
    
    def test_valid_string_variable(self):
        """Test creating a valid string variable."""
        var = VariableDefinition(
            name="project_name",
            type=VariableType.STRING,
            required=True,
            description="Name of the project",
            pattern=r"^[a-z][a-z0-9_]*$",
        )
        assert var.name == "project_name"
        assert var.type == VariableType.STRING
        assert var.required is True
    
    def test_valid_choice_variable(self):
        """Test creating a valid choice variable."""
        var = VariableDefinition(
            name="python_version",
            type=VariableType.CHOICE,
            required=True,
            description="Python version to use",
            choices=["3.11", "3.12", "3.13"],
            default="3.11",
        )
        assert var.type == VariableType.CHOICE
        assert len(var.choices) == 3
        assert var.default == "3.11"
    
    def test_choice_variable_requires_choices(self):
        """Test that choice type requires choices list."""
        with pytest.raises(ValidationError) as exc_info:
            VariableDefinition(
                name="version",
                type=VariableType.CHOICE,
                description="Python version",
                required=True,
            )
        assert "Choice type requires at least 2 choices" in str(exc_info.value)
    
    def test_invalid_variable_name(self):
        """Test that invalid variable names are rejected."""
        with pytest.raises(ValidationError):
            VariableDefinition(
                name="123invalid",  # Can't start with number
                type=VariableType.STRING,
                description="Test variable",
                required=True,
            )
    
    def test_default_must_be_in_choices(self):
        """Test that default value must be in choices."""
        with pytest.raises(ValidationError) as exc_info:
            VariableDefinition(
                name="version",
                type=VariableType.CHOICE,
                description="Python version",
                required=True,
                choices=["3.11", "3.12"],
                default="3.10",  # Not in choices
            )
        assert "must be in choices" in str(exc_info.value)


class TestTemplate:
    """Tests for Template model."""
    
    def test_valid_template(self, tmp_path):
        """Test creating a valid template."""
        template = Template(
            name="test-template",
            version="1.0.0",
            description="A test template for unit tests",
            template_type=TemplateType.PROJECT,
            local_path=tmp_path,
            size_bytes=1024,
            variables={
                "project_name": VariableDefinition(
                    name="project_name",
                    type=VariableType.STRING,
                    description="Project name",
                    required=True,
                )
            },
            created_at=datetime.now(),
            updated_at=datetime.now(),
        )
        assert template.name == "test-template"
        assert template.version == "1.0.0"
        assert len(template.variables) == 1
    
    def test_invalid_template_name(self, tmp_path):
        """Test that invalid template names are rejected."""
        with pytest.raises(ValidationError):
            Template(
                name="Invalid Name",  # Spaces not allowed
                version="1.0.0",
                description="Test template",
                local_path=tmp_path,
                size_bytes=1000,
                variables={},
                created_at=datetime.now(),
                updated_at=datetime.now(),
            )
    
    def test_invalid_version_format(self, tmp_path):
        """Test that invalid version formats are rejected."""
        with pytest.raises(ValidationError):
            Template(
                name="test-template",
                version="v1.0",  # Invalid format
                description="Test template",
                local_path=tmp_path,
                size_bytes=1000,
                variables={
                    "test": VariableDefinition(
                        name="test",
                        type=VariableType.STRING,
                        description="Test variable",
                        required=True,
                    )
                },
                created_at=datetime.now(),
                updated_at=datetime.now(),
            )
    
    def test_size_limit_exceeded(self, tmp_path):
        """Test that size limit is enforced."""
        with pytest.raises(ValidationError):
            Template(
                name="test-template",
                version="1.0.0",
                description="Test template",
                local_path=tmp_path,
                size_bytes=200_000_000,  # 200MB > 100MB limit
                variables={
                    "test": VariableDefinition(
                        name="test",
                        type=VariableType.STRING,
                        description="Test variable",
                        required=True,
                    )
                },
                created_at=datetime.now(),
                updated_at=datetime.now(),
            )


class TestProject:
    """Tests for Project model."""
    
    def test_valid_project(self, tmp_path):
        """Test creating a valid project."""
        project = Project(
            name="test-project",
            root_path=tmp_path,
            template_name="test-template",
            template_version="1.0.0",
            variables={"project_name": "test_project"},
            generated_files=[Path("README.md"), Path("main.py")],
            metadata_file=Path(".scaffold-metadata.json"),
            quality_status=QualityStatus.PASS,
            created_at=datetime.now(),
        )
        assert project.name == "test-project"
        assert len(project.generated_files) == 2
        assert project.quality_status == QualityStatus.PASS


class TestModule:
    """Tests for Module model."""
    
    def test_valid_module(self):
        """Test creating a valid module."""
        module = Module(
            name="auth_module",
            module_type=ModuleType.AUTH,
            template_name="auth-template",
            template_version="1.0.0",
            variables={"module_name": "auth"},
            generated_files=[Path("auth.py"), Path("models.py")],
            created_at=datetime.now(),
        )
        assert module.name == "auth_module"
        assert module.module_type == ModuleType.AUTH
        assert len(module.generated_files) == 2


class TestMergeModels:
    """Tests for merge-related models."""
    
    def test_conflict_region(self):
        """Test creating a conflict region."""
        region = ConflictRegion(
            start_line=10,
            end_line=15,
            user_content="user version",
            template_content="template version",
            base_content="original version",
        )
        assert region.start_line == 10
        assert region.end_line == 15
    
    def test_conflict_region_invalid_lines(self):
        """Test that end_line must be >= start_line."""
        with pytest.raises(ValidationError):
            ConflictRegion(
                start_line=15,
                end_line=10,  # Invalid: less than start_line
                user_content="user",
                template_content="template",
            )
    
    def test_merge_result(self, tmp_path):
        """Test creating a merge result."""
        conflict = ConflictRegion(
            start_line=10,
            end_line=15,
            user_content="user",
            template_content="template",
        )
        
        result = MergeResult(
            file_path=tmp_path / "test.py",
            merged_content="merged content with conflicts",
            has_conflicts=True,
            conflict_count=1,
            conflict_regions=[conflict],
            merge_strategy=MergeStrategy.THREE_WAY,
        )
        
        assert result.has_conflicts
        assert result.conflict_count == 1
        assert len(result.conflict_regions) == 1
    
    def test_merge_result_conflict_consistency(self, tmp_path):
        """Test that conflict_count must match regions length."""
        with pytest.raises(ValidationError):
            MergeResult(
                file_path=tmp_path / "test.py",
                merged_content="content",
                has_conflicts=True,
                conflict_count=2,  # Says 2 conflicts
                conflict_regions=[],  # But no regions
                merge_strategy=MergeStrategy.THREE_WAY,
            )
{% endif %}