{% if database == 'cockroachdb' -%}
/**
 * CockroachDB Database Integration
 * 
 * Distributed SQL database with PostgreSQL compatibility and horizontal scaling.
 * Best for: Multi-region applications, strong consistency requirements, automatic sharding
 * 
 * Features:
 * - PostgreSQL wire protocol compatibility
 * - Distributed ACID transactions
 * - Automatic data replication and rebalancing
 * - Built-in change data capture (CDC)
 * - Multi-region deployments with locality awareness
 * 
 * @see https://www.cockroachlabs.com/docs/
 */

import { Pool, PoolClient, QueryResult } from 'pg';

// Environment validation
const requiredEnvVars = [
  'COCKROACHDB_URL',
] as const;

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

export class CockroachDBError extends Error {
  constructor(
    message: string,
    public readonly code?: string,
    public readonly detail?: string
  ) {
    super(message);
    this.name = 'CockroachDBError';
  }
}

// Connection pool configuration
const pool = new Pool({
  connectionString: process.env.COCKROACHDB_URL,
  max: 20, // Maximum connections in pool
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
  // CockroachDB recommended settings
  statement_timeout: 30000, // 30 seconds
  application_name: 'saas-app',
});

/**
 * Execute a query with automatic retry for serialization errors
 */
export async function query<T = any>(
  sql: string,
  params: any[] = []
): Promise<QueryResult<T>> {
  const maxRetries = 3;
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await pool.query<T>(sql, params);
      return result;
    } catch (error: any) {
      // Retry on serialization errors (40001)
      if (error.code === '40001' && attempt < maxRetries) {
        lastError = error;
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 100));
        continue;
      }
      
      throw new CockroachDBError(
        error.message,
        error.code,
        error.detail
      );
    }
  }

  throw lastError || new Error('Query failed after retries');
}

/**
 * Execute a query and return first row or null
 */
export async function queryOne<T = any>(
  sql: string,
  params: any[] = []
): Promise<T | null> {
  const result = await query<T>(sql, params);
  return result.rows[0] || null;
}

/**
 * Execute a statement (INSERT, UPDATE, DELETE) and return affected rows
 */
export async function execute(
  sql: string,
  params: any[] = []
): Promise<number> {
  const result = await query(sql, params);
  return result.rowCount || 0;
}

/**
 * Execute multiple statements in a transaction with automatic retry
 */
export async function transaction<T>(
  callback: (client: PoolClient) => Promise<T>
): Promise<T> {
  const maxRetries = 3;
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      const result = await callback(client);
      await client.query('COMMIT');
      return result;
    } catch (error: any) {
      await client.query('ROLLBACK');
      
      // Retry on serialization errors
      if (error.code === '40001' && attempt < maxRetries) {
        lastError = error;
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 100));
        continue;
      }
      
      throw new CockroachDBError(
        error.message,
        error.code,
        error.detail
      );
    } finally {
      client.release();
    }
  }

  throw lastError || new Error('Transaction failed after retries');
}

/**
 * Execute AS OF SYSTEM TIME query for time-travel reads
 * Useful for historical queries and reducing contention
 */
export async function queryAsOf<T = any>(
  sql: string,
  params: any[] = [],
  secondsAgo: number = 10
): Promise<QueryResult<T>> {
  const timeTravel = `SELECT * FROM (${sql}) AS OF SYSTEM TIME '-${secondsAgo}s'`;
  return query<T>(timeTravel, params);
}

/**
 * Get connection pool statistics
 */
export function getPoolStats() {
  return {
    total: pool.totalCount,
    idle: pool.idleCount,
    waiting: pool.waitingCount,
  };
}

/**
 * Health check endpoint
 */
export async function healthCheck(): Promise<{
  healthy: boolean;
  latency?: number;
  error?: string;
  region?: string;
}> {
  const start = Date.now();
  
  try {
    const result = await query<{ gateway_region: string }>(
      'SELECT gateway_region() as gateway_region'
    );
    const latency = Date.now() - start;
    
    return {
      healthy: true,
      latency,
      region: result.rows[0]?.gateway_region,
    };
  } catch (error: any) {
    return {
      healthy: false,
      error: error.message,
    };
  }
}

/**
 * Close all connections in the pool
 */
export async function closePool(): Promise<void> {
  await pool.end();
}

// Graceful shutdown
process.on('SIGTERM', async () => {
  await closePool();
});
{%- endif %}
