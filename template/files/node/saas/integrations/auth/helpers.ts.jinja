{% if saas_starter_module == "enabled" %}
/**
 * Authentication Helper Functions
 * 
 * Unified authentication utilities that work across auth providers.
 * Provides a consistent interface regardless of Clerk or Auth.js selection.
 */

{% if saas_auth == "clerk" %}
import { auth, currentUser } from '@clerk/nextjs';
import { clerkClient } from '@clerk/nextjs';

export async function getSession() {
  const session = auth();
  return session.userId ? { userId: session.userId } : null;
}

export async function getUser() {
  return await currentUser();
}

export async function getUserId() {
  const { userId } = auth();
  return userId;
}

export async function requireUser() {
  const user = await currentUser();
  if (!user) {
    throw new Error('Unauthorized: No user session');
  }
  return user;
}

export async function requireUserId() {
  const { userId } = auth();
  if (!userId) {
    throw new Error('Unauthorized: No user session');
  }
  return userId;
}

{% elif saas_auth == "authjs" %}
import { auth } from '@/lib/auth/authjs/auth.config';

export async function getSession() {
  return await auth();
}

export async function getUser() {
  const session = await auth();
  return session?.user ?? null;
}

export async function getUserId() {
  const session = await auth();
  return session?.user?.id ?? null;
}

export async function requireUser() {
  const session = await auth();
  if (!session?.user) {
    throw new Error('Unauthorized: No user session');
  }
  return session.user;
}

export async function requireUserId() {
  const userId = await getUserId();
  if (!userId) {
    throw new Error('Unauthorized: No user session');
  }
  return userId;
}
{% endif %}

// ============================================================================
// Unified Organization Helpers (Clerk only)
// ============================================================================

{% if saas_auth == "clerk" %}
/**
 * Get current organization ID
 */
export async function getOrganizationId() {
  const { orgId } = auth();
  return orgId;
}

/**
 * Require organization context
 * Throws if user is not in an organization
 */
export async function requireOrganizationId() {
  const { orgId } = auth();
  if (!orgId) {
    throw new Error('Organization context required');
  }
  return orgId;
}

/**
 * Check if user has permission in organization
 */
export async function hasPermission(permission: string) {
  const { has } = auth();
  return has({ permission });
}

/**
 * Check if user has role in organization
 */
export async function hasRole(role: 'admin' | 'org:member') {
  const { has } = auth();
  return has({ role });
}
{% endif %}

// ============================================================================
// Session Utilities
// ============================================================================

/**
 * Check if user is authenticated
 * Returns boolean, doesn't throw
 */
export async function isAuthenticated() {
  {% if saas_auth == "clerk" %}
  const { userId } = auth();
  return !!userId;
  {% elif saas_auth == "authjs" %}
  const session = await auth();
  return !!session?.user;
  {% endif %}
}

/**
 * Get user email
 * Convenience method for common use case
 */
export async function getUserEmail() {
  {% if saas_auth == "clerk" %}
  const user = await currentUser();
  return user?.emailAddresses[0]?.emailAddress ?? null;
  {% elif saas_auth == "authjs" %}
  const session = await auth();
  return session?.user?.email ?? null;
  {% endif %}
}

/**
 * Get user display name
 * Falls back to email if name not set
 */
export async function getUserDisplayName() {
  {% if saas_auth == "clerk" %}
  const user = await currentUser();
  return user?.firstName 
    ? `${user.firstName} ${user.lastName || ''}`.trim()
    : user?.emailAddresses[0]?.emailAddress ?? 'User';
  {% elif saas_auth == "authjs" %}
  const session = await auth();
  return session?.user?.name ?? session?.user?.email ?? 'User';
  {% endif %}
}

// ============================================================================
// Error Classes
// ============================================================================

export class AuthError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'AuthError';
  }
}

export class UnauthorizedError extends AuthError {
  constructor(message = 'Unauthorized') {
    super(message);
    this.name = 'UnauthorizedError';
  }
}

export class ForbiddenError extends AuthError {
  constructor(message = 'Forbidden: Insufficient permissions') {
    super(message);
    this.name = 'ForbiddenError';
  }
}
{% endif %}
