{% if saas_starter_module == "enabled" and saas_billing == "stripe" %}
/**
 * Stripe Webhook Handlers
 * 
 * Best practices:
 * - Signature verification (security)
 * - Idempotency (prevent duplicate processing)
 * - Type-safe event handling
 * - Error handling and retry logic
 * - Audit logging
 * 
 * @see https://stripe.com/docs/webhooks
 */

import type Stripe from 'stripe';
import { stripe, verifyWebhook } from './client';
{% if saas_orm == 'prisma' %}
import { prisma } from '@/lib/database/client';
{% elif saas_orm == 'drizzle' %}
import { db } from '@/lib/database/client';
import { subscriptions, invoices } from '@/db/schema';
import { eq } from 'drizzle-orm';
{% endif %}
{% if saas_observability_structured_logging %}
import { logger } from '@/lib/observability/logger';
{% endif %}

// ============================================================================
// Webhook Event Handlers
// ============================================================================

/**
 * Handle checkout.session.completed
 * Triggered when customer completes checkout
 */
export async function handleCheckoutCompleted(
  session: Stripe.Checkout.Session
) {
  {% if saas_observability_structured_logging %}
  logger.info({
    msg: 'Checkout session completed',
    sessionId: session.id,
    customerId: session.customer,
    subscriptionId: session.subscription,
  });
  {% endif %}
  
  // Update subscription in database
  if (session.subscription && typeof session.subscription === 'string') {
    const subscription = await stripe.subscriptions.retrieve(session.subscription);
    
    {% if saas_orm == 'prisma' %}
    await prisma.subscription.upsert({
      where: { stripeSubscriptionId: subscription.id },
      create: {
        stripeCustomerId: subscription.customer as string,
        stripeSubscriptionId: subscription.id,
        stripePriceId: subscription.items.data[0].price.id,
        status: subscription.status,
        plan: subscription.items.data[0].price.lookup_key || 'unknown',
        billingCycle: subscription.items.data[0].price.recurring?.interval === 'year' ? 'annual' : 'monthly',
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
        metadata: session.metadata,
      },
      update: {
        status: subscription.status,
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      },
    });
    {% elif saas_orm == 'drizzle' %}
    // Drizzle upsert pattern
    const existing = await db.query.subscriptions.findFirst({
      where: eq(subscriptions.stripeSubscriptionId, subscription.id),
    });
    
    if (existing) {
      await db.update(subscriptions)
        .set({
          status: subscription.status as any,
          currentPeriodStart: new Date(subscription.current_period_start * 1000),
          currentPeriodEnd: new Date(subscription.current_period_end * 1000),
          updatedAt: new Date(),
        })
        .where(eq(subscriptions.id, existing.id));
    } else {
      await db.insert(subscriptions).values({
        stripeCustomerId: subscription.customer as string,
        stripeSubscriptionId: subscription.id,
        stripePriceId: subscription.items.data[0].price.id,
        status: subscription.status as any,
        plan: subscription.items.data[0].price.lookup_key || 'unknown',
        billingCycle: subscription.items.data[0].price.recurring?.interval === 'year' ? 'annual' : 'monthly',
        currentPeriodStart: new Date(subscription.current_period_start * 1000),
        currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      });
    }
    {% endif %}
  }
}

/**
 * Handle invoice.paid
 * Triggered when invoice payment succeeds
 */
export async function handleInvoicePaid(invoice: Stripe.Invoice) {
  {% if saas_observability_structured_logging %}
  logger.info({
    msg: 'Invoice paid',
    invoiceId: invoice.id,
    subscriptionId: invoice.subscription,
    amount: invoice.amount_paid,
  });
  {% endif %}
  
  // Store invoice record
  {% if saas_orm == 'prisma' %}
  await prisma.invoice.upsert({
    where: { stripeInvoiceId: invoice.id },
    create: {
      stripeInvoiceId: invoice.id,
      subscriptionId: '', // Get from subscription lookup
      status: invoice.status || 'open',
      amountDue: invoice.amount_due,
      amountPaid: invoice.amount_paid,
      currency: invoice.currency,
      hostedInvoiceUrl: invoice.hosted_invoice_url,
      invoicePdfUrl: invoice.invoice_pdf,
      paidAt: invoice.status_transitions.paid_at ? new Date(invoice.status_transitions.paid_at * 1000) : null,
    },
    update: {
      status: invoice.status || 'open',
      amountPaid: invoice.amount_paid,
      paidAt: invoice.status_transitions.paid_at ? new Date(invoice.status_transitions.paid_at * 1000) : null,
    },
  });
  {% endif %}
  
  // Update subscription status to active if it was trialing
  if (invoice.subscription) {
    const subscriptionId = typeof invoice.subscription === 'string' 
      ? invoice.subscription 
      : invoice.subscription.id;
    
    {% if saas_orm == 'prisma' %}
    await prisma.subscription.updateMany({
      where: { stripeSubscriptionId: subscriptionId },
      data: { status: 'active' },
    });
    {% elif saas_orm == 'drizzle' %}
    await db.update(subscriptions)
      .set({ status: 'active', updatedAt: new Date() })
      .where(eq(subscriptions.stripeSubscriptionId, subscriptionId));
    {% endif %}
  }
}

/**
 * Handle invoice.payment_failed
 * Triggered when payment fails
 */
export async function handleInvoicePaymentFailed(invoice: Stripe.Invoice) {
  {% if saas_observability_structured_logging %}
  logger.warn({
    msg: 'Invoice payment failed',
    invoiceId: invoice.id,
    subscriptionId: invoice.subscription,
    attemptCount: invoice.attempt_count,
  });
  {% endif %}
  
  // Update subscription status to past_due
  if (invoice.subscription) {
    const subscriptionId = typeof invoice.subscription === 'string'
      ? invoice.subscription
      : invoice.subscription.id;
    
    {% if saas_orm == 'prisma' %}
    await prisma.subscription.updateMany({
      where: { stripeSubscriptionId: subscriptionId },
      data: { status: 'past_due' },
    });
    {% elif saas_orm == 'drizzle' %}
    await db.update(subscriptions)
      .set({ status: 'past_due', updatedAt: new Date() })
      .where(eq(subscriptions.stripeSubscriptionId, subscriptionId));
    {% endif %}
  }
  
  // TODO: Send payment failed email notification
}

/**
 * Handle customer.subscription.updated
 * Triggered when subscription changes
 */
export async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
  {% if saas_observability_structured_logging %}
  logger.info({
    msg: 'Subscription updated',
    subscriptionId: subscription.id,
    status: subscription.status,
  });
  {% endif %}
  
  {% if saas_orm == 'prisma' %}
  await prisma.subscription.updateMany({
    where: { stripeSubscriptionId: subscription.id },
    data: {
      status: subscription.status,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
    },
  });
  {% elif saas_orm == 'drizzle' %}
  await db.update(subscriptions)
    .set({
      status: subscription.status as any,
      currentPeriodStart: new Date(subscription.current_period_start * 1000),
      currentPeriodEnd: new Date(subscription.current_period_end * 1000),
      cancelAtPeriodEnd: subscription.cancel_at_period_end,
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id));
  {% endif %}
}

/**
 * Handle customer.subscription.deleted
 * Triggered when subscription is canceled
 */
export async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
  {% if saas_observability_structured_logging %}
  logger.info({
    msg: 'Subscription deleted',
    subscriptionId: subscription.id,
  });
  {% endif %}
  
  {% if saas_orm == 'prisma' %}
  await prisma.subscription.updateMany({
    where: { stripeSubscriptionId: subscription.id },
    data: {
      status: 'canceled',
      canceledAt: new Date(),
    },
  });
  {% elif saas_orm == 'drizzle' %}
  await db.update(subscriptions)
    .set({
      status: 'canceled',
      canceledAt: new Date(),
      updatedAt: new Date(),
    })
    .where(eq(subscriptions.stripeSubscriptionId, subscription.id));
  {% endif %}
}

// ============================================================================
// Webhook Router
// ============================================================================

/**
 * Main webhook handler
 * Routes events to appropriate handlers
 * 
 * @example
 * ```ts
 * // In app/api/webhooks/stripe/route.ts
 * export async function POST(req: Request) {
 *   const payload = await req.text();
 *   const signature = req.headers.get('stripe-signature')!;
 *   
 *   await processWebhook(payload, signature);
 *   return new Response('OK', { status: 200 });
 * }
 * ```
 */
export async function processWebhook(payload: string, signature: string) {
  const event = await verifyWebhook(payload, signature);
  
  // Route to appropriate handler
  switch (event.type) {
    case 'checkout.session.completed':
      await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session);
      break;
    
    case 'invoice.paid':
      await handleInvoicePaid(event.data.object as Stripe.Invoice);
      break;
    
    case 'invoice.payment_failed':
      await handleInvoicePaymentFailed(event.data.object as Stripe.Invoice);
      break;
    
    case 'customer.subscription.updated':
      await handleSubscriptionUpdated(event.data.object as Stripe.Subscription);
      break;
    
    case 'customer.subscription.deleted':
      await handleSubscriptionDeleted(event.data.object as Stripe.Subscription);
      break;
    
    default:
      {% if saas_observability_structured_logging %}
      logger.info({
        msg: 'Unhandled webhook event',
        type: event.type,
        eventId: event.id,
      });
      {% endif %}
  }
}
{% endif %}
