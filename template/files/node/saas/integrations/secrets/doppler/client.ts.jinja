{% if secrets == 'doppler' -%}
/**
 * Doppler Secrets Management Integration
 * 
 * Universal secrets manager with automatic environment synchronization.
 * Manages secrets across dev/staging/prod environments with version history.
 * 
 * Features:
 * - Multi-environment secret sync (dev/staging/prod/custom)
 * - Dynamic secrets loading into process.env
 * - Automatic secret updates with polling
 * - Version history and rollback
 * - Team collaboration and access controls
 * - CLI integration for local development
 * 
 * @example
 * ```typescript
 * import { dopplerClient, loadSecrets, getSecret } from './integrations/secrets/doppler';
 * 
 * // Load all secrets into environment
 * await loadSecrets();
 * 
 * // Get specific secret
 * const apiKey = await getSecret('API_KEY');
 * 
 * // Get secret with fallback
 * const dbUrl = await getSecret('DATABASE_URL', 'postgresql://localhost');
 * ```
 */

import axios, { AxiosInstance } from 'axios';

// Environment variables
const DOPPLER_TOKEN = process.env.DOPPLER_TOKEN;
const DOPPLER_PROJECT = process.env.DOPPLER_PROJECT || 'default';
const DOPPLER_CONFIG = process.env.DOPPLER_CONFIG || 'dev';

if (!DOPPLER_TOKEN) {
  throw new Error('DOPPLER_TOKEN environment variable is required');
}

/**
 * Doppler API client
 */
class DopplerClient {
  private client: AxiosInstance;
  private cache: Map<string, { value: string; timestamp: number }>;
  private cacheTTL: number = 300000; // 5 minutes

  constructor() {
    this.client = axios.create({
      baseURL: 'https://api.doppler.com/v3',
      headers: {
        'Authorization': `Bearer ${DOPPLER_TOKEN}`,
        'Content-Type': 'application/json',
      },
    });
    this.cache = new Map();
  }

  /**
   * Get all secrets for current environment
   */
  async getAllSecrets(): Promise<Record<string, string>> {
    try {
      const response = await this.client.get('/configs/config/secrets/download', {
        params: {
          project: DOPPLER_PROJECT,
          config: DOPPLER_CONFIG,
          format: 'json',
        },
      });

      return response.data;
    } catch (error) {
      console.error('Failed to fetch secrets from Doppler:', error);
      throw error;
    }
  }

  /**
   * Get specific secret by name
   */
  async getSecret(name: string, fallback?: string): Promise<string | undefined> {
    // Check cache
    const cached = this.cache.get(name);
    if (cached && Date.now() - cached.timestamp < this.cacheTTL) {
      return cached.value;
    }

    try {
      const response = await this.client.get('/configs/config/secret', {
        params: {
          project: DOPPLER_PROJECT,
          config: DOPPLER_CONFIG,
          name,
        },
      });

      const value = response.data.value.raw;
      
      // Update cache
      this.cache.set(name, { value, timestamp: Date.now() });
      
      return value;
    } catch (error) {
      console.error(`Failed to fetch secret ${name} from Doppler:`, error);
      return fallback;
    }
  }

  /**
   * Load all secrets into process.env
   * Useful for initializing application with all secrets
   */
  async loadSecretsToEnv(): Promise<void> {
    const secrets = await this.getAllSecrets();
    
    Object.entries(secrets).forEach(([key, value]) => {
      process.env[key] = value;
    });

    console.log(`Loaded ${Object.keys(secrets).length} secrets from Doppler`);
  }

  /**
   * List all available configs (environments)
   */
  async listConfigs(): Promise<Array<{ name: string; environment: string }>> {
    try {
      const response = await this.client.get('/configs', {
        params: {
          project: DOPPLER_PROJECT,
        },
      });

      return response.data.configs.map((config: any) => ({
        name: config.name,
        environment: config.environment,
      }));
    } catch (error) {
      console.error('Failed to list Doppler configs:', error);
      throw error;
    }
  }

  /**
   * Get secret with automatic refresh
   * Starts a polling mechanism to keep secrets up-to-date
   */
  watchSecret(name: string, callback: (value: string) => void, interval: number = 60000): () => void {
    const poll = async () => {
      const value = await this.getSecret(name);
      if (value) {
        callback(value);
      }
    };

    // Initial fetch
    poll();

    // Set up polling
    const intervalId = setInterval(poll, interval);

    // Return cleanup function
    return () => clearInterval(intervalId);
  }

  /**
   * Clear secret cache
   */
  clearCache(): void {
    this.cache.clear();
  }

  /**
   * Health check
   */
  async healthCheck(): Promise<boolean> {
    try {
      await this.client.get('/me');
      return true;
    } catch (error) {
      console.error('Doppler health check failed:', error);
      return false;
    }
  }
}

// Singleton instance
export const dopplerClient = new DopplerClient();

/**
 * Get secret by name with optional fallback
 */
export const getSecret = (name: string, fallback?: string) => 
  dopplerClient.getSecret(name, fallback);

/**
 * Load all secrets into process.env
 */
export const loadSecrets = () => 
  dopplerClient.loadSecretsToEnv();

/**
 * Get all secrets as object
 */
export const getAllSecrets = () => 
  dopplerClient.getAllSecrets();

/**
 * List available configs/environments
 */
export const listConfigs = () => 
  dopplerClient.listConfigs();

/**
 * Watch secret for changes
 */
export const watchSecret = (name: string, callback: (value: string) => void, interval?: number) => 
  dopplerClient.watchSecret(name, callback, interval);

/**
 * Clear cache
 */
export const clearCache = () => 
  dopplerClient.clearCache();

/**
 * Health check
 */
export const healthCheck = () => 
  dopplerClient.healthCheck();

export default dopplerClient;
{%- endif %}
