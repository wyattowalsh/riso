{% if secrets_management == 'infisical' -%}
/**
 * Infisical Secrets Management Integration
 * 
 * Open-source secrets management platform with end-to-end encryption.
 * Best for: Developer-friendly secrets, audit logs, secret rotation, multi-environment
 * 
 * Features:
 * - End-to-end encrypted secrets
 * - Secret versioning and rollback
 * - Point-in-time recovery
 * - Audit logs and access controls
 * - Secret rotation and expiration
 * - Multiple environments (dev, staging, prod)
 * - Secret referencing and dependencies
 * 
 * @see https://infisical.com/docs
 */

import { InfisicalClient } from '@infisical/sdk';

// Environment validation
const requiredEnvVars = [
  'INFISICAL_CLIENT_ID',
  'INFISICAL_CLIENT_SECRET',
] as const;

for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    throw new Error(`Missing required environment variable: ${envVar}`);
  }
}

export class InfisicalError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'InfisicalError';
  }
}

// Initialize Infisical client
const client = new InfisicalClient({
  clientId: process.env.INFISICAL_CLIENT_ID!,
  clientSecret: process.env.INFISICAL_CLIENT_SECRET!,
  siteUrl: process.env.INFISICAL_SITE_URL, // Optional: self-hosted
});

// Cache for secrets (with TTL)
const secretCache = new Map<string, { value: string; expiresAt: number }>();
const DEFAULT_CACHE_TTL = 5 * 60 * 1000; // 5 minutes

/**
 * Get a secret value
 */
export async function getSecret(
  secretName: string,
  options: {
    environment?: string;
    projectId?: string;
    path?: string;
    useCache?: boolean;
  } = {}
): Promise<string> {
  const {
    environment = process.env.INFISICAL_ENVIRONMENT || 'production',
    projectId = process.env.INFISICAL_PROJECT_ID,
    path = '/',
    useCache = true,
  } = options;

  if (!projectId) {
    throw new InfisicalError('Project ID is required');
  }

  // Check cache
  const cacheKey = `${projectId}:${environment}:${path}:${secretName}`;
  if (useCache) {
    const cached = secretCache.get(cacheKey);
    if (cached && cached.expiresAt > Date.now()) {
      return cached.value;
    }
  }

  try {
    const secret = await client.getSecret({
      secretName,
      projectId,
      environment,
      path,
    });

    // Cache the secret
    if (useCache && secret.secretValue) {
      secretCache.set(cacheKey, {
        value: secret.secretValue,
        expiresAt: Date.now() + DEFAULT_CACHE_TTL,
      });
    }

    return secret.secretValue;
  } catch (error: any) {
    throw new InfisicalError(
      `Failed to get secret ${secretName}: ${error.message}`
    );
  }
}

/**
 * Get multiple secrets at once
 */
export async function getSecrets(
  options: {
    environment?: string;
    projectId?: string;
    path?: string;
    useCache?: boolean;
  } = {}
): Promise<Record<string, string>> {
  const {
    environment = process.env.INFISICAL_ENVIRONMENT || 'production',
    projectId = process.env.INFISICAL_PROJECT_ID,
    path = '/',
    useCache = true,
  } = options;

  if (!projectId) {
    throw new InfisicalError('Project ID is required');
  }

  try {
    const secrets = await client.listSecrets({
      projectId,
      environment,
      path,
    });

    const result: Record<string, string> = {};
    
    for (const secret of secrets) {
      result[secret.secretKey] = secret.secretValue;
      
      // Cache each secret
      if (useCache) {
        const cacheKey = `${projectId}:${environment}:${path}:${secret.secretKey}`;
        secretCache.set(cacheKey, {
          value: secret.secretValue,
          expiresAt: Date.now() + DEFAULT_CACHE_TTL,
        });
      }
    }

    return result;
  } catch (error: any) {
    throw new InfisicalError(
      `Failed to get secrets: ${error.message}`
    );
  }
}

/**
 * Create or update a secret
 */
export async function setSecret(
  secretName: string,
  secretValue: string,
  options: {
    environment?: string;
    projectId?: string;
    path?: string;
    type?: 'shared' | 'personal';
  } = {}
): Promise<void> {
  const {
    environment = process.env.INFISICAL_ENVIRONMENT || 'production',
    projectId = process.env.INFISICAL_PROJECT_ID,
    path = '/',
    type = 'shared',
  } = options;

  if (!projectId) {
    throw new InfisicalError('Project ID is required');
  }

  try {
    await client.createSecret({
      secretName,
      secretValue,
      projectId,
      environment,
      path,
      type,
    });

    // Invalidate cache
    const cacheKey = `${projectId}:${environment}:${path}:${secretName}`;
    secretCache.delete(cacheKey);
  } catch (error: any) {
    // If secret exists, update it
    if (error.message.includes('already exists')) {
      try {
        await client.updateSecret({
          secretName,
          secretValue,
          projectId,
          environment,
          path,
        });
        
        // Invalidate cache
        const cacheKey = `${projectId}:${environment}:${path}:${secretName}`;
        secretCache.delete(cacheKey);
        return;
      } catch (updateError: any) {
        throw new InfisicalError(
          `Failed to update secret ${secretName}: ${updateError.message}`
        );
      }
    }
    
    throw new InfisicalError(
      `Failed to set secret ${secretName}: ${error.message}`
    );
  }
}

/**
 * Delete a secret
 */
export async function deleteSecret(
  secretName: string,
  options: {
    environment?: string;
    projectId?: string;
    path?: string;
  } = {}
): Promise<void> {
  const {
    environment = process.env.INFISICAL_ENVIRONMENT || 'production',
    projectId = process.env.INFISICAL_PROJECT_ID,
    path = '/',
  } = options;

  if (!projectId) {
    throw new InfisicalError('Project ID is required');
  }

  try {
    await client.deleteSecret({
      secretName,
      projectId,
      environment,
      path,
    });

    // Invalidate cache
    const cacheKey = `${projectId}:${environment}:${path}:${secretName}`;
    secretCache.delete(cacheKey);
  } catch (error: any) {
    throw new InfisicalError(
      `Failed to delete secret ${secretName}: ${error.message}`
    );
  }
}

/**
 * Clear the secret cache
 */
export function clearCache(): void {
  secretCache.clear();
}

/**
 * Load secrets into environment variables
 * Useful for initializing app with all secrets
 */
export async function loadSecretsToEnv(
  options: {
    environment?: string;
    projectId?: string;
    path?: string;
    prefix?: string;
  } = {}
): Promise<number> {
  const { prefix = '' } = options;
  
  try {
    const secrets = await getSecrets(options);
    let count = 0;
    
    for (const [key, value] of Object.entries(secrets)) {
      const envKey = prefix + key;
      process.env[envKey] = value;
      count++;
    }
    
    return count;
  } catch (error: any) {
    throw new InfisicalError(
      `Failed to load secrets to environment: ${error.message}`
    );
  }
}

/**
 * Example: Database connection string from secrets
 */
export async function getDatabaseUrl(): Promise<string> {
  const host = await getSecret('DB_HOST');
  const port = await getSecret('DB_PORT');
  const user = await getSecret('DB_USER');
  const password = await getSecret('DB_PASSWORD');
  const database = await getSecret('DB_NAME');
  
  return `postgresql://${user}:${password}@${host}:${port}/${database}`;
}

/**
 * Health check endpoint
 */
export async function healthCheck(): Promise<{
  healthy: boolean;
  latency?: number;
  error?: string;
}> {
  const start = Date.now();
  
  try {
    // Try to fetch a test secret or list secrets
    await getSecrets({ useCache: false });
    const latency = Date.now() - start;
    
    return {
      healthy: true,
      latency,
    };
  } catch (error: any) {
    return {
      healthy: false,
      error: error.message,
    };
  }
}
{%- endif %}
