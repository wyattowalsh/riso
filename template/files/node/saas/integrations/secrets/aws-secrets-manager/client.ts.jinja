{% if secrets == 'aws-secrets-manager' -%}
/**
 * AWS Secrets Manager Integration
 * 
 * Enterprise-grade secret storage with automatic rotation.
 * Integrates deeply with AWS services for fine-grained access control.
 * 
 * Features:
 * - Automatic secret rotation (RDS, Redshift, DocumentDB)
 * - Fine-grained IAM access control
 * - Secret versioning with staging labels
 * - Cross-region secret replication
 * - Deep AWS service integration
 * - Encryption with AWS KMS
 * - CloudTrail audit logging
 * 
 * @example
 * ```typescript
 * import { getSecret, createSecret, rotateSecret } from './integrations/secrets/aws-secrets-manager';
 * 
 * // Get secret value
 * const dbPassword = await getSecret('prod/db/password');
 * 
 * // Get parsed JSON secret
 * const dbCreds = await getSecretJSON<{ username: string; password: string }>('prod/db/credentials');
 * 
 * // Create new secret
 * await createSecret('prod/api/key', 'secret-value');
 * 
 * // Rotate secret (for RDS)
 * await rotateSecret('prod/db/password');
 * ```
 */

import {
  SecretsManagerClient,
  GetSecretValueCommand,
  CreateSecretCommand,
  UpdateSecretCommand,
  DeleteSecretCommand,
  RotateSecretCommand,
  ListSecretsCommand,
  DescribeSecretCommand,
  PutSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';

// Environment variables
const AWS_REGION = process.env.AWS_REGION || 'us-east-1';
const AWS_ACCESS_KEY_ID = process.env.AWS_ACCESS_KEY_ID;
const AWS_SECRET_ACCESS_KEY = process.env.AWS_SECRET_ACCESS_KEY;

if (!AWS_ACCESS_KEY_ID || !AWS_SECRET_ACCESS_KEY) {
  throw new Error('AWS credentials (AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY) are required');
}

/**
 * AWS Secrets Manager client
 */
const client = new SecretsManagerClient({
  region: AWS_REGION,
  credentials: {
    accessKeyId: AWS_ACCESS_KEY_ID,
    secretAccessKey: AWS_SECRET_ACCESS_KEY,
  },
});

// Cache for secrets
const cache = new Map<string, { value: string; timestamp: number }>();
const CACHE_TTL = 300000; // 5 minutes

/**
 * Get secret value by name/ARN
 */
export async function getSecret(secretId: string, versionId?: string): Promise<string> {
  // Check cache
  const cacheKey = versionId ? `${secretId}:${versionId}` : secretId;
  const cached = cache.get(cacheKey);
  
  if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
    return cached.value;
  }

  try {
    const command = new GetSecretValueCommand({
      SecretId: secretId,
      VersionId: versionId,
    });

    const response = await client.send(command);
    const value = response.SecretString || Buffer.from(response.SecretBinary!).toString('utf-8');

    // Update cache
    cache.set(cacheKey, { value, timestamp: Date.now() });

    return value;
  } catch (error) {
    console.error(`Failed to get secret ${secretId}:`, error);
    throw error;
  }
}

/**
 * Get secret and parse as JSON
 */
export async function getSecretJSON<T = any>(secretId: string, versionId?: string): Promise<T> {
  const value = await getSecret(secretId, versionId);
  return JSON.parse(value);
}

/**
 * Create new secret
 */
export async function createSecret(
  name: string,
  secretValue: string,
  description?: string,
  kmsKeyId?: string
): Promise<{ arn: string; name: string }> {
  try {
    const command = new CreateSecretCommand({
      Name: name,
      Description: description,
      SecretString: secretValue,
      KmsKeyId: kmsKeyId,
    });

    const response = await client.send(command);

    return {
      arn: response.ARN!,
      name: response.Name!,
    };
  } catch (error) {
    console.error(`Failed to create secret ${name}:`, error);
    throw error;
  }
}

/**
 * Update existing secret
 */
export async function updateSecret(secretId: string, secretValue: string): Promise<void> {
  try {
    const command = new PutSecretValueCommand({
      SecretId: secretId,
      SecretString: secretValue,
    });

    await client.send(command);

    // Clear cache for this secret
    cache.delete(secretId);
  } catch (error) {
    console.error(`Failed to update secret ${secretId}:`, error);
    throw error;
  }
}

/**
 * Delete secret (with recovery window)
 */
export async function deleteSecret(
  secretId: string,
  recoveryWindowInDays: number = 30
): Promise<void> {
  try {
    const command = new DeleteSecretCommand({
      SecretId: secretId,
      RecoveryWindowInDays: recoveryWindowInDays,
    });

    await client.send(command);

    // Clear cache for this secret
    cache.delete(secretId);
  } catch (error) {
    console.error(`Failed to delete secret ${secretId}:`, error);
    throw error;
  }
}

/**
 * Rotate secret (requires Lambda rotation function)
 */
export async function rotateSecret(
  secretId: string,
  rotationLambdaARN?: string
): Promise<void> {
  try {
    const command = new RotateSecretCommand({
      SecretId: secretId,
      RotationLambdaARN: rotationLambdaARN,
      RotationRules: {
        AutomaticallyAfterDays: 30, // Rotate every 30 days
      },
    });

    await client.send(command);

    // Clear cache for this secret
    cache.delete(secretId);
  } catch (error) {
    console.error(`Failed to rotate secret ${secretId}:`, error);
    throw error;
  }
}

/**
 * List all secrets
 */
export async function listSecrets(): Promise<Array<{
  name: string;
  arn: string;
  description?: string;
  lastChangedDate?: Date;
}>> {
  try {
    const command = new ListSecretsCommand({});
    const response = await client.send(command);

    return (response.SecretList || []).map(secret => ({
      name: secret.Name!,
      arn: secret.ARN!,
      description: secret.Description,
      lastChangedDate: secret.LastChangedDate,
    }));
  } catch (error) {
    console.error('Failed to list secrets:', error);
    throw error;
  }
}

/**
 * Get secret metadata
 */
export async function getSecretMetadata(secretId: string): Promise<{
  name: string;
  arn: string;
  description?: string;
  rotationEnabled: boolean;
  lastRotatedDate?: Date;
  lastChangedDate?: Date;
}> {
  try {
    const command = new DescribeSecretCommand({
      SecretId: secretId,
    });

    const response = await client.send(command);

    return {
      name: response.Name!,
      arn: response.ARN!,
      description: response.Description,
      rotationEnabled: response.RotationEnabled || false,
      lastRotatedDate: response.LastRotatedDate,
      lastChangedDate: response.LastChangedDate,
    };
  } catch (error) {
    console.error(`Failed to get metadata for secret ${secretId}:`, error);
    throw error;
  }
}

/**
 * Helper: Get database credentials (common use case)
 */
export async function getDatabaseCredentials(secretId: string): Promise<{
  username: string;
  password: string;
  engine: string;
  host: string;
  port: number;
  dbname: string;
}> {
  return getSecretJSON(secretId);
}

/**
 * Clear cache
 */
export function clearCache(): void {
  cache.clear();
}

/**
 * Health check
 */
export async function healthCheck(): Promise<boolean> {
  try {
    await client.send(new ListSecretsCommand({ MaxResults: 1 }));
    return true;
  } catch (error) {
    console.error('AWS Secrets Manager health check failed:', error);
    return false;
  }
}

export default client;
{%- endif %}
