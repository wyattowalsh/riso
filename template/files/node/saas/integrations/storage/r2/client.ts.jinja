{% if saas_starter_module == "enabled" and saas_storage == "r2" %}
/**
 * Cloudflare R2 Storage Client
 * 
 * S3-compatible object storage patterns:
 * - File upload/download
 * - Presigned URLs
 * - Multipart uploads
 * - Public/private buckets
 * - CDN integration
 * 
 * @see https://developers.cloudflare.com/r2/
 */

import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand, ListObjectsV2Command, HeadObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { env } from '@/lib/env';

// Initialize R2 client (S3-compatible)
export const r2 = new S3Client({
  region: 'auto',
  endpoint: env.R2_ENDPOINT, // https://<account-id>.r2.cloudflarestorage.com
  credentials: {
    accessKeyId: env.R2_ACCESS_KEY_ID,
    secretAccessKey: env.R2_SECRET_ACCESS_KEY,
  },
});

const BUCKET_NAME = env.R2_BUCKET_NAME;

// ============================================================================
// File Upload
// ============================================================================

/**
 * Upload file to R2
 * 
 * @example
 * ```ts
 * await uploadFile({
 *   key: 'uploads/image.jpg',
 *   body: fileBuffer,
 *   contentType: 'image/jpeg',
 * });
 * ```
 */
export async function uploadFile(params: {
  key: string;
  body: Buffer | Uint8Array | Blob | string;
  contentType?: string;
  metadata?: Record<string, string>;
}) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: params.key,
    Body: params.body as any,
    ContentType: params.contentType,
    Metadata: params.metadata,
  });
  
  await r2.send(command);
  
  return {
    key: params.key,
    url: `${env.R2_PUBLIC_URL}/${params.key}`,
  };
}

/**
 * Upload file with progress tracking
 * For large files (>5MB), use multipart upload
 */
export async function uploadLargeFile(params: {
  key: string;
  body: Buffer;
  contentType?: string;
  onProgress?: (progress: number) => void;
}) {
  // TODO: Implement multipart upload for files >5MB
  return await uploadFile(params);
}

// ============================================================================
// File Download
// ============================================================================

/**
 * Download file from R2
 */
export async function downloadFile(key: string): Promise<Buffer> {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
  });
  
  const response = await r2.send(command);
  const stream = response.Body as any;
  
  // Convert stream to buffer
  const chunks: Uint8Array[] = [];
  for await (const chunk of stream) {
    chunks.push(chunk);
  }
  
  return Buffer.concat(chunks);
}

/**
 * Get file metadata
 */
export async function getFileMetadata(key: string) {
  const command = new HeadObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
  });
  
  const response = await r2.send(command);
  
  return {
    contentType: response.ContentType,
    contentLength: response.ContentLength,
    lastModified: response.LastModified,
    metadata: response.Metadata,
  };
}

// ============================================================================
// Presigned URLs
// ============================================================================

/**
 * Generate presigned URL for upload
 * Allows direct client-side uploads
 * 
 * @example
 * ```ts
 * const uploadUrl = await generateUploadUrl({
 *   key: 'uploads/image.jpg',
 *   expiresIn: 3600, // 1 hour
 * });
 * 
 * // Client can now upload directly to this URL
 * await fetch(uploadUrl, {
 *   method: 'PUT',
 *   body: file,
 * });
 * ```
 */
export async function generateUploadUrl(params: {
  key: string;
  expiresIn?: number; // seconds
  contentType?: string;
}) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: params.key,
    ContentType: params.contentType,
  });
  
  return await getSignedUrl(r2, command, {
    expiresIn: params.expiresIn || 3600,
  });
}

/**
 * Generate presigned URL for download
 * For private files
 */
export async function generateDownloadUrl(params: {
  key: string;
  expiresIn?: number;
}) {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: params.key,
  });
  
  return await getSignedUrl(r2, command, {
    expiresIn: params.expiresIn || 3600,
  });
}

// ============================================================================
// File Management
// ============================================================================

/**
 * Delete file
 */
export async function deleteFile(key: string) {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
  });
  
  await r2.send(command);
}

/**
 * List files in directory
 */
export async function listFiles(params: {
  prefix?: string;
  maxKeys?: number;
}) {
  const command = new ListObjectsV2Command({
    Bucket: BUCKET_NAME,
    Prefix: params.prefix,
    MaxKeys: params.maxKeys || 1000,
  });
  
  const response = await r2.send(command);
  
  return {
    files: response.Contents?.map((item) => ({
      key: item.Key!,
      size: item.Size!,
      lastModified: item.LastModified!,
    })) || [],
    hasMore: response.IsTruncated || false,
  };
}

/**
 * Check if file exists
 */
export async function fileExists(key: string): Promise<boolean> {
  try {
    await getFileMetadata(key);
    return true;
  } catch (error) {
    return false;
  }
}

// ============================================================================
// File Utilities
// ============================================================================

/**
 * Generate unique file key
 */
export function generateFileKey(params: {
  prefix?: string;
  filename: string;
  userId?: string;
}): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  const sanitized = params.filename.replace(/[^a-zA-Z0-9.-]/g, '_');
  
  const parts = [
    params.prefix,
    params.userId,
    `${timestamp}-${random}-${sanitized}`,
  ].filter(Boolean);
  
  return parts.join('/');
}

/**
 * Get file extension
 */
export function getFileExtension(filename: string): string {
  return filename.split('.').pop()?.toLowerCase() || '';
}

/**
 * Get MIME type from extension
 */
export function getMimeType(extension: string): string {
  const mimeTypes: Record<string, string> = {
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    png: 'image/png',
    gif: 'image/gif',
    webp: 'image/webp',
    pdf: 'application/pdf',
    txt: 'text/plain',
    json: 'application/json',
    mp4: 'video/mp4',
    mp3: 'audio/mpeg',
  };
  
  return mimeTypes[extension] || 'application/octet-stream';
}

// ============================================================================
// Type Exports
// ============================================================================

export type { S3Client };
{% endif %}
