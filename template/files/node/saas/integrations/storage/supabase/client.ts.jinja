{% if saas_starter_module == "enabled" and saas_storage == "supabase-storage" %}
/**
 * Supabase Storage Client
 * 
 * Modern storage patterns:
 * - File upload/download
 * - Public/private buckets
 * - Image transformations
 * - Access control
 * - CDN integration
 * 
 * @see https://supabase.com/docs/guides/storage
 */

import { createClient } from '@supabase/supabase-js';
import { env } from '@/lib/env';

// Initialize Supabase client
const supabase = createClient(
  env.NEXT_PUBLIC_SUPABASE_URL,
  env.SUPABASE_SERVICE_ROLE_KEY // Use service role for server-side operations
);

const BUCKET_NAME = env.SUPABASE_STORAGE_BUCKET || 'uploads';

// ============================================================================
// File Upload
// ============================================================================

/**
 * Upload file to Supabase Storage
 * 
 * @example
 * ```ts
 * await uploadFile({
 *   path: 'avatars/user123.jpg',
 *   file: fileBuffer,
 *   contentType: 'image/jpeg',
 * });
 * ```
 */
export async function uploadFile(params: {
  path: string;
  file: File | Blob | Buffer | ArrayBuffer;
  contentType?: string;
  upsert?: boolean;
}) {
  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .upload(params.path, params.file, {
      contentType: params.contentType,
      upsert: params.upsert ?? false,
    });
  
  if (error) {
    throw new StorageError(error.message);
  }
  
  return {
    path: data.path,
    url: getPublicUrl(data.path),
  };
}

/**
 * Upload file with progress tracking
 */
export async function uploadFileWithProgress(params: {
  path: string;
  file: File;
  onProgress?: (progress: number) => void;
}) {
  // Supabase doesn't directly support progress callbacks
  // Use a workaround with chunks
  return await uploadFile({
    path: params.path,
    file: params.file,
  });
}

// ============================================================================
// File Download
// ============================================================================

/**
 * Download file from Supabase Storage
 */
export async function downloadFile(path: string): Promise<Blob> {
  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .download(path);
  
  if (error) {
    throw new StorageError(error.message);
  }
  
  return data;
}

/**
 * Get file metadata
 */
export async function getFileMetadata(path: string) {
  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .list(path.split('/').slice(0, -1).join('/'), {
      search: path.split('/').pop(),
    });
  
  if (error) {
    throw new StorageError(error.message);
  }
  
  return data[0];
}

// ============================================================================
// Public URLs
// ============================================================================

/**
 * Get public URL for file
 * Works for public buckets
 */
export function getPublicUrl(path: string): string {
  const { data } = supabase.storage
    .from(BUCKET_NAME)
    .getPublicUrl(path);
  
  return data.publicUrl;
}

/**
 * Get public URL with image transformations
 * 
 * @example
 * ```ts
 * const url = getPublicUrlWithTransform('avatars/user.jpg', {
 *   width: 300,
 *   height: 300,
 *   quality: 80,
 * });
 * ```
 */
export function getPublicUrlWithTransform(
  path: string,
  transform: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'webp' | 'avif';
  }
): string {
  const { data } = supabase.storage
    .from(BUCKET_NAME)
    .getPublicUrl(path, {
      transform: {
        width: transform.width,
        height: transform.height,
        quality: transform.quality,
        format: transform.format,
      },
    });
  
  return data.publicUrl;
}

/**
 * Create signed URL for private files
 * 
 * @example
 * ```ts
 * const url = await createSignedUrl('private/document.pdf', 3600);
 * ```
 */
export async function createSignedUrl(
  path: string,
  expiresIn: number = 3600 // seconds
): Promise<string> {
  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .createSignedUrl(path, expiresIn);
  
  if (error) {
    throw new StorageError(error.message);
  }
  
  return data.signedUrl;
}

// ============================================================================
// File Management
// ============================================================================

/**
 * Delete file
 */
export async function deleteFile(path: string) {
  const { error } = await supabase.storage
    .from(BUCKET_NAME)
    .remove([path]);
  
  if (error) {
    throw new StorageError(error.message);
  }
}

/**
 * Delete multiple files
 */
export async function deleteFiles(paths: string[]) {
  const { error } = await supabase.storage
    .from(BUCKET_NAME)
    .remove(paths);
  
  if (error) {
    throw new StorageError(error.message);
  }
}

/**
 * List files in directory
 */
export async function listFiles(params: {
  path?: string;
  limit?: number;
  offset?: number;
  sortBy?: 'name' | 'created_at' | 'updated_at';
}) {
  const { data, error } = await supabase.storage
    .from(BUCKET_NAME)
    .list(params.path, {
      limit: params.limit || 100,
      offset: params.offset || 0,
      sortBy: { column: params.sortBy || 'created_at', order: 'desc' },
    });
  
  if (error) {
    throw new StorageError(error.message);
  }
  
  return data.map((file) => ({
    name: file.name,
    id: file.id,
    size: file.metadata?.size || 0,
    mimeType: file.metadata?.mimetype,
    createdAt: file.created_at,
    updatedAt: file.updated_at,
  }));
}

/**
 * Move file
 */
export async function moveFile(fromPath: string, toPath: string) {
  const { error } = await supabase.storage
    .from(BUCKET_NAME)
    .move(fromPath, toPath);
  
  if (error) {
    throw new StorageError(error.message);
  }
}

/**
 * Copy file
 */
export async function copyFile(fromPath: string, toPath: string) {
  const { error } = await supabase.storage
    .from(BUCKET_NAME)
    .copy(fromPath, toPath);
  
  if (error) {
    throw new StorageError(error.message);
  }
}

// ============================================================================
// File Utilities
// ============================================================================

/**
 * Generate unique file path
 */
export function generateFilePath(params: {
  folder?: string;
  filename: string;
  userId?: string;
}): string {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  const sanitized = params.filename.replace(/[^a-zA-Z0-9.-]/g, '_');
  
  const parts = [
    params.folder,
    params.userId,
    `${timestamp}-${random}-${sanitized}`,
  ].filter(Boolean);
  
  return parts.join('/');
}

/**
 * Validate file type
 */
export function validateFileType(
  file: File,
  allowedTypes: string[]
): boolean {
  return allowedTypes.some((type) => {
    if (type.endsWith('/*')) {
      return file.type.startsWith(type.replace('/*', ''));
    }
    return file.type === type;
  });
}

/**
 * Validate file size
 */
export function validateFileSize(
  file: File,
  maxSizeBytes: number
): boolean {
  return file.size <= maxSizeBytes;
}

// ============================================================================
// Error Handling
// ============================================================================

export class StorageError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'StorageError';
  }
}

// ============================================================================
// Type Exports
// ============================================================================

export { supabase };
{% endif %}
