#!/usr/bin/env python3
"""Validate release configuration files in rendered projects.

This script validates .commitlintrc.yml, .releaserc.yml, and riso-release.yml
files against their JSON schemas and ensures configuration consistency.

Usage:
    python scripts/ci/validate_release_configs.py [--project-dir <path>]

Arguments:
    --project-dir: Path to rendered project directory (default: samples/default/render)

Exit codes:
    0: All validations passed
    1: Validation failures detected

Generated by Riso template - Feature 014: Changelog & Release Management
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Optional

# Import shared validation utilities
sys.path.insert(0, str(Path(__file__).parent.parent))
from lib.validation import (
    ValidationResult,
    YAMLLoadResult,
    load_yaml_file,
    validate_path_exists,
    validate_required_fields,
    create_validation_result,
    print_error_list,
)
from lib.logger import logger, configure_logging

try:
    import yaml
except ImportError:
    logger.error("PyYAML not installed")
    logger.info("Install with: pip install pyyaml")
    sys.exit(1)


def validate_commitlint_config(config_path: Path) -> tuple[bool, list[str]]:
    """Validate .commitlintrc.yml configuration.

    Args:
        config_path: Path to .commitlintrc.yml

    Returns:
        Tuple of (is_valid, errors)
    """
    errors = []

    if not config_path.exists():
        return True, []  # Not an error if changelog module disabled

    # Use shared YAML loading utility
    result = load_yaml_file(config_path)
    if not result["success"]:
        errors.append(f".commitlintrc.yml: {result['error']}")
        return False, errors

    config = result["data"]

    # Validate required fields using shared utility
    field_errors = validate_required_fields(
        config,
        ['extends', 'rules'],
        context=".commitlintrc.yml"
    )
    errors.extend(field_errors)

    # Validate type-enum rule
    if 'rules' in config:
        if 'type-enum' not in config['rules']:
            errors.append(".commitlintrc.yml: Missing 'type-enum' rule")
        else:
            type_enum = config['rules']['type-enum']
            if not isinstance(type_enum, list) or len(type_enum) < 3:
                errors.append(".commitlintrc.yml: Invalid 'type-enum' format")

    return len(errors) == 0, errors


def validate_semantic_release_config(config_path: Path) -> tuple[bool, list[str]]:
    """Validate .releaserc.yml configuration.

    Args:
        config_path: Path to .releaserc.yml

    Returns:
        Tuple of (is_valid, errors)
    """
    errors = []

    if not config_path.exists():
        return True, []  # Not an error if changelog module disabled

    # Use shared YAML loading utility
    result = load_yaml_file(config_path)
    if not result["success"]:
        errors.append(f".releaserc.yml: {result['error']}")
        return False, errors

    config = result["data"]

    # Validate required fields using shared utility
    field_errors = validate_required_fields(
        config,
        ['branches', 'plugins'],
        context=".releaserc.yml"
    )
    errors.extend(field_errors)

    # Check for required plugins
    if 'plugins' in config:
        plugins = config['plugins']

        required_plugins = [
            '@semantic-release/commit-analyzer',
            '@semantic-release/release-notes-generator',
            '@semantic-release/changelog',
        ]

        plugin_names = []
        for plugin in plugins:
            if isinstance(plugin, str):
                plugin_names.append(plugin)
            elif isinstance(plugin, list) and len(plugin) > 0:
                plugin_names.append(plugin[0])

        for required in required_plugins:
            if required not in plugin_names:
                errors.append(f".releaserc.yml: Missing required plugin: {required}")

    return len(errors) == 0, errors


def validate_release_workflow(workflow_path: Path) -> tuple[bool, list[str]]:
    """Validate riso-release.yml workflow.

    Args:
        workflow_path: Path to .github/workflows/riso-release.yml

    Returns:
        Tuple of (is_valid, errors)
    """
    errors = []

    if not workflow_path.exists():
        return True, []  # Not an error if changelog module disabled

    # Use shared YAML loading utility
    result = load_yaml_file(workflow_path)
    if not result["success"]:
        errors.append(f"riso-release.yml: {result['error']}")
        return False, errors

    workflow = result["data"]

    # Validate required fields using shared utility
    field_errors = validate_required_fields(
        workflow,
        ['name', 'on', 'jobs'],
        context="riso-release.yml"
    )
    errors.extend(field_errors)

    # Validate release job exists and has required structure
    if 'jobs' in workflow:
        jobs = workflow['jobs']

        if 'release' not in jobs:
            errors.append("riso-release.yml: Missing 'release' job")
        else:
            release_job = jobs['release']

            # Validate job structure
            job_errors = validate_required_fields(
                release_job,
                ['runs-on', 'steps'],
                context="riso-release.yml: release job"
            )
            errors.extend(job_errors)

            # Check for required steps
            if 'steps' in release_job:
                steps = release_job['steps']
                step_names = [step.get('name', '') for step in steps]

                if not any('semantic-release' in name.lower() for name in step_names):
                    errors.append("riso-release.yml: Missing semantic-release step")

    return len(errors) == 0, errors


def main() -> int:
    """Main entry point for validation script.

    Returns:
        Exit code: 0 for success, 1 for failure
    """
    configure_logging()

    parser = argparse.ArgumentParser(
        description='Validate release configuration files'
    )
    parser.add_argument(
        '--project-dir',
        type=Path,
        default=Path('samples/default/render'),
        help='Path to rendered project directory'
    )

    args = parser.parse_args()
    project_dir = args.project_dir

    # Use shared path validation utility
    path_result = validate_path_exists(project_dir, must_be_dir=True)
    if not path_result["valid"]:
        logger.error("Project directory validation failed:")
        for error in path_result["errors"]:
            logger.error(f"  - {error}")
        return 1

    logger.info("Validating release configurations...")
    logger.info(f"Project directory: {project_dir}")
    logger.info("")
    
    all_valid = True
    all_errors = []

    # Validate commitlint config
    logger.info("Validating .commitlintrc.yml...")
    commitlint_path = project_dir / '.commitlintrc.yml'
    is_valid, errors = validate_commitlint_config(commitlint_path)

    if not is_valid:
        all_valid = False
        all_errors.extend(errors)
        logger.error("Validation failed")
    elif commitlint_path.exists():
        logger.info("Valid")
    else:
        logger.info("Not present (changelog module disabled)")
    logger.info("")

    # Validate semantic-release config
    logger.info("Validating .releaserc.yml...")
    releaserc_path = project_dir / '.releaserc.yml'
    is_valid, errors = validate_semantic_release_config(releaserc_path)

    if not is_valid:
        all_valid = False
        all_errors.extend(errors)
        logger.error("Validation failed")
    elif releaserc_path.exists():
        logger.info("Valid")
    else:
        logger.info("Not present (changelog module disabled)")
    logger.info("")

    # Validate release workflow
    logger.info("Validating .github/workflows/riso-release.yml...")
    workflow_path = project_dir / '.github' / 'workflows' / 'riso-release.yml'
    is_valid, errors = validate_release_workflow(workflow_path)

    if not is_valid:
        all_valid = False
        all_errors.extend(errors)
        logger.error("Validation failed")
    elif workflow_path.exists():
        logger.info("Valid")
    else:
        logger.info("Not present (changelog module disabled)")
    logger.info("")
    
    # Print errors using shared utility
    if all_errors:
        print_error_list(all_errors, title="Validation Errors")
        return 1

    logger.info("=" * 70)
    logger.info("All validation checks passed!")
    logger.info("=" * 70)

    return 0


if __name__ == "__main__":
    sys.exit(main())
