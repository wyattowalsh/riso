# WebSocket Quickstart Guide

**Feature**: 008-websockets-scaffold | **Updated**: 2025-11-01

## Overview

This guide walks through setting up WebSocket support in your Riso project for real-time bidirectional communication between clients and servers.

**What you'll build**: A WebSocket endpoint with connection management, heartbeat monitoring, room-based broadcasting, and authentication.

**Time to complete**: 15-20 minutes

**Prerequisites**:

- Python 3.11+ with uv installed
- FastAPI ≥0.104.0 (from spec 006)
- Basic understanding of async/await

## Step 1: Enable WebSocket Module

When creating a new project or updating an existing one, enable the WebSocket module:

```bash
# New project with WebSocket support
copier copy gh:your-org/riso my-websocket-app \
  --data websocket_module=enabled

# Update existing project
cd my-existing-app
copier update --data websocket_module=enabled
```

This adds:

- `src/<package>/websocket/` - WebSocket implementation
- `tests/test_websocket.py` - Test fixtures and examples
- `docs/modules/websockets.md` - Full documentation

## Step 2: Start the Development Server

```bash
# Install dependencies
uv sync

# Run with uvicorn (supports WebSocket protocol upgrade)
uv run uvicorn my_app.api.main:app --host 0.0.0.0 --port 8000 --reload

# Server should report:
# INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
# INFO:     Application startup complete.
```

**Verify WebSocket endpoint**: Open <http://localhost:8000/docs> and look for `/ws` endpoint in Swagger UI.

## Step 3: Connect from Python Client

Create a simple client to test the connection:

```python
# client.py
import asyncio
import websockets
import json
from datetime import datetime

async def test_websocket():
    uri = "ws://localhost:8000/ws"
    
    async with websockets.connect(uri) as websocket:
        # Receive connection confirmation
        connect_msg = await websocket.recv()
        data = json.loads(connect_msg)
        print(f"Connected: {data['payload']['connection_id']}")
        
        # Send a text message
        message = {
            "type": "message.text",
            "payload": {"text": "Hello from Python!"},
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
        await websocket.send(json.dumps(message))
        
        # Receive response
        response = await websocket.recv()
        print(f"Response: {response}")

if __name__ == "__main__":
    asyncio.run(test_websocket())
```

Run the client:

```bash
uv run python client.py
# Expected output:
# Connected: 650e8400-e29b-41d4-a716-446655440001
# Response: {"type":"message.text","payload":{"text":"Hello from Python!"},...}
```

## Step 4: Test Room Broadcasting

Join a room and broadcast messages:

```python
# broadcast_client.py
import asyncio
import websockets
import json
from datetime import datetime
import uuid

async def broadcast_demo():
    uri = "ws://localhost:8000/ws"
    
    async with websockets.connect(uri) as ws:
        # Wait for connection
        await ws.recv()
        
        # Join room
        join_request = {
            "type": "room.join",
            "message_id": str(uuid.uuid4()),
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "sender_id": "client",
            "payload": {"room_id": "chat_general"}
        }
        await ws.send(json.dumps(join_request))
        
        # Receive join confirmation
        join_response = await ws.recv()
        print(f"Joined: {join_response}")
        
        # Broadcast to room
        broadcast_msg = {
            "type": "room.broadcast",
            "message_id": str(uuid.uuid4()),
            "timestamp": datetime.utcnow().isoformat() + "Z",
            "sender_id": "client",
            "payload": {
                "room_id": "chat_general",
                "message": {"type": "message.text", "text": "Hello room!"},
                "exclude_sender": False
            }
        }
        await ws.send(json.dumps(broadcast_msg))
        
        # Receive broadcast echo
        echo = await ws.recv()
        print(f"Broadcast echo: {echo}")

if __name__ == "__main__":
    asyncio.run(broadcast_demo())
```

## Step 5: Add Authentication (Optional)

Enable authentication for WebSocket connections:

```python
# In src/<package>/websocket/main.py (generated by template)

from fastapi import WebSocket, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from jose import JWTError, jwt

security = HTTPBearer()

async def get_current_user_websocket(
    websocket: WebSocket,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """Authenticate WebSocket connections via JWT token."""
    try:
        token = credentials.credentials
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("sub")
        if user_id is None:
            await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
            raise HTTPException(status_code=401, detail="Invalid token")
        return user_id
    except JWTError:
        await websocket.close(code=status.WS_1008_POLICY_VIOLATION)
        raise HTTPException(status_code=401, detail="Invalid token")

@app.websocket("/ws")
async def websocket_endpoint(
    websocket: WebSocket,
    user_id: str = Depends(get_current_user_websocket)
):
    """WebSocket endpoint with authentication."""
    await manager.connect(websocket, user_id=user_id)
    # ... rest of handler
```

Connect with token:

```python
# authenticated_client.py
import asyncio
import websockets

async def connect_with_auth():
    token = "your-jwt-token-here"
    uri = f"ws://localhost:8000/ws"
    headers = {"Authorization": f"Bearer {token}"}
    
    async with websockets.connect(uri, extra_headers=headers) as ws:
        connect_msg = await ws.recv()
        print(f"Authenticated: {connect_msg}")

asyncio.run(connect_with_auth())
```

## Step 6: Monitor Connection Health

The WebSocket implementation includes automatic heartbeat monitoring:

```python
# The server sends heartbeat.ping every 30 seconds
# Clients should respond with heartbeat.pong

async def handle_heartbeat(websocket):
    """Client-side heartbeat handler."""
    async for message in websocket:
        data = json.loads(message)
        
        if data["type"] == "heartbeat.ping":
            pong = {
                "type": "heartbeat.pong",
                "message_id": str(uuid.uuid4()),
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "payload": {
                    "ping_message_id": data["message_id"],
                    "client_time": datetime.utcnow().isoformat() + "Z"
                }
            }
            await websocket.send(json.dumps(pong))
```

**Configuration** (environment variables):

```bash
# .env file
WS_HEARTBEAT_INTERVAL=30      # Ping interval (seconds)
WS_HEARTBEAT_TIMEOUT=60       # Pong timeout (seconds)
WS_IDLE_TIMEOUT=300           # Idle connection timeout (seconds)
WS_MAX_MESSAGE_SIZE=1048576   # Max message size (1MB)
WS_MESSAGE_QUEUE_DEPTH=100    # Outbound queue size
```

## Step 7: Test with Browser Client

Create an HTML client for browser testing:

```html
<!-- websocket-test.html -->
<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Test</title>
</head>
<body>
    <h1>WebSocket Test Client</h1>
    <button id="connect">Connect</button>
    <button id="disconnect" disabled>Disconnect</button>
    <input id="message" type="text" placeholder="Enter message" />
    <button id="send" disabled>Send</button>
    <div id="log"></div>

    <script>
        let ws = null;
        const log = document.getElementById('log');
        
        document.getElementById('connect').onclick = () => {
            ws = new WebSocket('ws://localhost:8000/ws');
            
            ws.onopen = () => {
                log.innerHTML += '<p>Connected!</p>';
                document.getElementById('connect').disabled = true;
                document.getElementById('disconnect').disabled = false;
                document.getElementById('send').disabled = false;
            };
            
            ws.onmessage = (event) => {
                const data = JSON.parse(event.data);
                log.innerHTML += `<p>← ${JSON.stringify(data)}</p>`;
                
                // Auto-respond to heartbeat
                if (data.type === 'heartbeat.ping') {
                    ws.send(JSON.stringify({
                        type: 'heartbeat.pong',
                        message_id: crypto.randomUUID(),
                        timestamp: new Date().toISOString(),
                        payload: {
                            ping_message_id: data.message_id,
                            client_time: new Date().toISOString()
                        }
                    }));
                }
            };
            
            ws.onclose = () => {
                log.innerHTML += '<p>Disconnected</p>';
                document.getElementById('connect').disabled = false;
                document.getElementById('disconnect').disabled = true;
                document.getElementById('send').disabled = true;
            };
        };
        
        document.getElementById('disconnect').onclick = () => {
            ws.close();
        };
        
        document.getElementById('send').onclick = () => {
            const text = document.getElementById('message').value;
            const message = {
                type: 'message.text',
                message_id: crypto.randomUUID(),
                timestamp: new Date().toISOString(),
                sender_id: 'browser',
                payload: { text }
            };
            ws.send(JSON.stringify(message));
            log.innerHTML += `<p>→ ${text}</p>`;
            document.getElementById('message').value = '';
        };
    </script>
</body>
</html>
```

Open `websocket-test.html` in your browser to test interactively.

## Step 8: Run Tests

The template includes comprehensive tests:

```bash
# Run WebSocket tests
uv run pytest tests/test_websocket.py -v

# Run with coverage
uv run pytest tests/test_websocket.py --cov=src/my_app/websocket

# Expected output:
# tests/test_websocket.py::test_connection_lifecycle PASSED
# tests/test_websocket.py::test_heartbeat_mechanism PASSED
# tests/test_websocket.py::test_room_broadcasting PASSED
# tests/test_websocket.py::test_authentication PASSED
# tests/test_websocket.py::test_backpressure PASSED
# tests/test_websocket.py::test_idle_timeout PASSED
# ========================= 6 passed in 2.45s =========================
```

## Common Patterns

### Pattern 1: Typing Indicator

```python
# Send typing indicator to room
typing_msg = {
    "type": "room.broadcast",
    "message_id": str(uuid.uuid4()),
    "timestamp": datetime.utcnow().isoformat() + "Z",
    "sender_id": user_id,
    "payload": {
        "room_id": "chat_general",
        "message": {
            "type": "user.typing",
            "user_id": user_id,
            "is_typing": True
        },
        "exclude_sender": True  # Don't send back to sender
    }
}
```

### Pattern 2: Direct Message

```python
# Send message to specific connection
await manager.send_json(
    connection_id="target-connection-id",
    message={
        "type": "message.text",
        "payload": {"text": "Private message"},
        "sender_id": your_connection_id
    }
)
```

### Pattern 3: Error Handling

```python
try:
    await websocket.send(json.dumps(message))
except websockets.exceptions.ConnectionClosed:
    print("Connection closed unexpectedly")
except asyncio.QueueFull:
    print("Backpressure: message queue full")
```

## Next Steps

- **Production deployment**: See `docs/modules/websockets.md` for ASGI server configuration (uvicorn/hypercorn)
- **Multi-server setup**: Review Redis pub/sub pattern in documentation for horizontal scaling
- **Monitoring**: Integrate with Prometheus (spec 010) for WebSocket metrics
- **Database integration**: Add message persistence using SQLAlchemy (spec 008)

## Troubleshooting

**Problem**: `Connection refused on ws://localhost:8000/ws`

- **Solution**: Ensure uvicorn is running with `--reload` flag and WebSocket module is enabled

**Problem**: `401 Unauthorized` on connection

- **Solution**: Check JWT token is valid and not expired, ensure `Authorization` header is set

**Problem**: `Message too large` error

- **Solution**: Reduce message size or increase `WS_MAX_MESSAGE_SIZE` environment variable

**Problem**: Connection drops after 5 minutes

- **Solution**: Implement heartbeat pong response on client side (see Step 6)

**Problem**: `Backpressure` errors

- **Solution**: Client is not reading messages fast enough; increase `WS_MESSAGE_QUEUE_DEPTH` or improve client processing speed

## Documentation

- **Full module docs**: `docs/modules/websockets.md` (generated in your project)
- **API reference**: <http://localhost:8000/docs> (Swagger UI when server running)
- **JSON schemas**: `contracts/` directory for message format specifications

## Support

For issues or questions:

1. Check generated documentation in `docs/modules/websockets.md`
2. Review test examples in `tests/test_websocket.py`
3. Consult spec 008 in `specs/008-websockets-scaffold/`
